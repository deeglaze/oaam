\documentclass[preprint,onecolumn,9pt]{sigplanconf} %{onecol}
\usepackage{alltt,mathpartir}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{graphicx}
\usepackage{balance}
\usepackage{calc}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\newcommand{\naive}{naive}
\newcommand{\naively}{naively}
\newcommand{\Naive}{Naive}
\newcommand{\Naively}{Naively}
% \usepackage{xltxtra}
% \setmonofont[Scale=MatchLowercase]{DejaVu Sans Mono}
%
\input{preamble}

\begin{document}

\conferenceinfo{WXYZ '05}{date, City.}
\copyrightyear{2005}
\copyrightdata{[to be supplied]}

% \titlebanner{banner above paper title}        % These are ignored unless
% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Optimizing Abstract Abstract Machines}

\authorinfo{J. Ian Johnson}
           {Northeastern University}
           {ianj@ccs.neu.edu}
\authorinfo{Matthew Might}
           {University of Utah}
           {might@cs.utah.edu}
\authorinfo{David Van Horn}
           {Northeastern University}
           {dvanhorn@ccs.neu.edu}

\maketitle

\begin{abstract}
Abstracting abstract machines has been proposed as a
lightweight approach to designing sound and computable program
analyses.  The approach derives abstract interpreters from
existing machine semantics and has been applied to a variety of
languages with features widely considered difficult to analyze.
Although sound analyzers are straightforward to build under this approach,
they are also prohibitively inefficient.

This article contributes a step-by-step process for going from a
\naive{} analyzer derived under the abstracting abstract machine
approach to an efficient program analyzer.  The end result of the
process is a two to three order-of-magnitude improvement over the
systematically derived analyzer, making it competitive with
hand-optimized implementations that compute fundamentally less precise
results.
\end{abstract}

%% \category{CR-number}{subcategory}{third-level}

%% \terms
%% term1, term2

%% \keywords
%% keyword1, keyword2

\section{Introduction}

The \emph{abstracting abstract machines} (AAM)
approach~\cite{dvanhorn:VanHorn2011Abstracting,dvanhorn:VanHorn2012Systematic}
to deriving program analyses provides a systematic way of transforming a
programming language semantics in the form of an abstract machine into a family
of abstract interpreters.
%
The approach parameterizes these families with policies for regulating analytic
precision.
%
While flexible and robust, the AAM approach unfortunately yields analyzers with
poor performance relative to hand-optimized analyzers.
%
Our work takes aim squarely at this ``efficiency gap,'' and narrows it in an
equally systematic way.

%
% Specifically, these policies tune precision for control,
% the environment, the store, and base value domains.  

By taking a
machine-oriented view of computation, AAM makes it possible to design,
verify, and implement program analyzers for realistic language
features typically considered difficult to model.  The approach was
originally applied to features such as higher-order functions,
stack inspection, exceptions, laziness, first-class continuations, and
garbage collection.  It has since been used to verify actor-
\cite{local:DOsualdo:12A} and
thread-based~\cite{dvanhorn:Might2011Family} parallelism and
behavioral contracts~\cite{dvanhorn:TobinHochstadt2012Higherorder}; it
has been used to model Coq~\cite{local:harvard},
Dalvik~\cite{local:dalvik}, Erlang~\cite{local:DOsualdo:12B},
JavaScript~\cite{local:DBLP:journals/corr/abs-1109-4467}, and
Racket~\cite{dvanhorn:TobinHochstadt2012Higherorder}.

The primary strength of the approach is that abstract interpreters can
be easily derived through a small number of steps from existing
machine models.  Since the relationships between abstract machines and
higher-level semantic models---such as definitional
interpreters~\cite{dvanhorn:reynolds-hosc98}, structured operational
semantics~\cite{dvanhorn:Plotkin1981Structural}, and reduction
semantics~\cite{dvanhorn:Felleisen2009Semantics}---are well
understood~\cite{dvanhorn:Danvy:DSc}, it is possible to navigate from
these high-level semantic models to sound program analyzers in a
systematic way.  Moreover, since these analyses so closely resemble a
language's interpreter (a) implementing an analysis requires little
more than implementing an interpreter, (b) a single implementation can
serve as both an interpreter and analyzer, and (c) verifying the
correctness of the implementation is straightforward.

However, there is a considerable weakness with the approach: an
analyzer designed and implemented by following the AAM recipe is
prohibitively inefficient without both further approximation and
further implementation effort.

In this article, we develop a systematic approach to deriving the
feasible implementation of an abstract-machine-based analyzer.

\section{At a glance}

\begin{figure}[t]
\begin{center}
\includegraphics[width=3.2in]{church-relative-space}
\includegraphics[width=3.2in]{church-relative-speed}
\includegraphics[width=3.2in]{church-relative-time}
\vspace{-1.5em}
\end{center}
\caption{Factor improvements over the baseline analyzer for the
  \Church{} benchmark in terms of peak memory usage, the rate of state
  transitions, and total analysis time. (Bigger is better.) Each point
  is marked with the section that introduces the optimization.}
\label{fig:churchtime}
\end{figure}


This paper is organized in two halfs: in the first, we start with a
quick review of the AAM approach to develop an analysis framework and
then apply our step-by-step optimization techniques in the simplified
setting of a core functional language.  This allows us to explicate
the optimizations with a minimal amount of inessential technical
overhead.  In the second half, we scale this approach up to an
analyzer for a realistic untyped, higher-order imperative language
with a number of interesting features and then measure
improvements across a suite of benchmarks.

At each step during the initial presentation and development, we evaluate the
implementation on a benchmark from Vardoulakis and
Shivers~\cite{dvanhorn:Vardoulakis2011CFA2} that tests distributivity
of multiplication over addition on Church numerals.
For the step-by-step development, 
this benchmark is particularly informative:
\begin{enumerate}
\item it can be written in most modern programming languages,
%
\item it was designed to stress an analyzer's ability to deal with
  complicated environment and control structure arising from the use
  of higher-order functions to encode arithmetic, and
%
\item it proves to be the \emph{least} improved benchmark of the
  complete suite considered in section~\ref{sec:eval}, and thus it
  serves as a good sanity check and lower-bound for each of the
  optimization techniques considered.
\end{enumerate}

We start, in section~\ref{sec:aam}, by developing an abstract
interpreter according to the AAM approach.  Without further
abstraction, the analysis is exponential due to per-state store
variance and thus cannot analyze the example in a reasonable amount of
time.  In section~\ref{sec:baseline}, we perform a further abstraction
by widening the store.  The resulting analyzer sacrifices precision
for speed and is able to analyze the example in about 1 minute.  This
step is described by Van Horn and Might~\cite[\S
  3.5--6]{dvanhorn:VanHorn2012Systematic} and is necessary to make
even small examples feasible.  We therefore take the widened
interpreter as the baseline for our evaluation.

Section~\ref{sec:opt} gives a series of simple abstractions and
implementation techniques that, in total, speed up the analysis by
nearly a factor of 500, dropping the analysis time to a fraction of a
second.  Figure~\ref{fig:churchtime} shows the step-wise improvement
of the analysis time for this example.

\begin{figure}[t]
\begin{center}
\begin{tabular}{ccc}
\raisebox{1ex-\height}{
\includegraphics[height=3.5in]{introspective-base.pdf}}
&
\raisebox{1ex-\height}{
\includegraphics[height=3.5in]{introspective-lazy.pdf}}
&
\raisebox{1ex-\height}{
\includegraphics[height=3in]{introspective-lazyc.pdf}}
\\
(a) Baseline
&
(b) Lazy
&
(c) Compiled (\& lazy)
\end{tabular}
\end{center}
\caption{Example state graphs for the program above.  Part (a) shows
  the result of the baseline analyzer.  It has long ``corridor''
  transitions and ``diamond'' subgraphs that fan-out from
  nondeterminism and fan-in from joins.  Part (b) shows the result of
  performing nondeterminism lazily and thus avoids many of the diamond
  subgraphs.  Part (c) shows the result of abstract compilation that
  removes interpretive overhead in the form of intermediate states,
  thus minimizing the corridor transitions.  The end result is a more
  compact abstraction of the program that can be generated faster.}
\label{fig:state-graphs}
\end{figure}

The AAM approach, in essence, does the following: it takes a
machine-based view of computation and turns it into a \emph{finitary
  approximation} by bounding the size of the store.  With a limited
address space, the store must map addresses to \emph{sets} of values.
Store updates are interpreted as joins, and store dereferences are
interpreted by non-deterministic choice of an element from a set.  The
result of analyzing a program is a finite directed graph where nodes
in the graph are (abstract) machine states and edges denote machine
transitions between states.

The techniques we propose for optimizing analysis fall into the
following categories:
\begin{enumerate}
\item generate fewer states by avoiding the eager exploration of
  non-deterministic choices that will later collapse into a single
  join point.  We accomplish this by applying lazy evaluation
  techniques so that non-determinism is evaluated \emph{by need}.

\item generate fewer states by avoiding unnecessary, intermediate
  states of a computation.  We accomplish this by applying compilation
  techniques from functional languages to avoid interpretive overhead
  in the machine transition system.

\item generate states faster.  We accomplish this by better algorithm
  design in the fixed-point computation we use to generate state graphs.
\end{enumerate}
Figure~\ref{fig:state-graphs} shows the effect of (1) and (2) for a
small example due to Earl, et
al.~\cite{dvanhorn:Earl2012Introspective}.
By generating significantly fewer states at a significantly faster
rate, we are able to achieve large performance improvements in terms
of both time and space.

Section~\ref{sec:eval} describes the evaluation of each optimization
technique applied to an implementation supporting a more realistic set
of features, including mutation, first-class control, compound data, a
full numeric tower and many more forms of primitive data and
operations.
%
We evaluate this implementation against a set of benchmark programs
drawn from the literature.
%
For all benchmarks, the optimized analyzer outperforms the baseline
by at least a factor of
% 475
two to
% 4,382
three orders of magnitude.

Section~\ref{sec:related} relates this work to the literature and
section~\ref{sec:conclusion} concludes.

%\newpage
\section{An analyzer for ISWIM}
\label{sec:aam}

In this section, we give a brief review of the AAM approach by
defining a sound analytic framework for a core higher-order functional
language: Landin's ISWIM~\cite{dvanhorn:Landin1966Next}.  In the
subsequent sections, we will explore optimizations for the analyzer in
this simplified setting, but scaling these techniques to realistic
languages is straightforward and has been done for the analyzer
evaluated in section~\ref{sec:eval}.

ISWIM is a family of programming languages parameterized by a set of
base values and operations.  To make things concrete, we consider a
member of the ISWIM family with integers, booleans, and a few
operations.
%
Figure~\ref{fig:syntax} defines the (abstract) syntax of ISWIM.  It
includes variables, literals (either integers, booleans, or
operations), $\lambda$-expressions for defining procedures, procedure
applications, and conditionals.  Expressions carry a label, $\mlab$,
which is drawn from an unspecified set and denotes the source location
of the expression; labels are used to disambiguate distinct, but
syntactically identical pieces of syntax.  We omit the label
annotation in contexts where it is irrelevant.

\begin{figure}
\[
\begin{array}{l@{\qquad}rcl}
\text{Expressions} & \mexp &=& \svar[^\mlab]\mvar\\
&&|& \slit[^\mlab]\mlit\\
&&|& \slam[^\mlab]\mvar\mexp\\
&&|& \sapp[^\mlab]\mexp\mexp \\
&&|& \sif[^\mlab]\mexp\mexp\mexp \\
\text{Variables}&\mvar &=& \syntax{x}\ |\ \syntax{y}\ |\ \dots\\
\text{Literals}&\mlit &=& \mnum\ |\ \mbln\ |\ \mop\\
\text{Integers}&\mnum &=& \syntax{0}\ |\ \syntax{1}\ |\ \syntax{-1}\ |\ \dots\\
\text{Booleans}&\mbln &=& \strue\ |\ \sfalse\\
\text{Operations}&\mop &=& \syntax{zero?}\ |\ \syntax{add1}\ |\ \syntax{sub1}\ |\ \dots
\end{array}
\]
\caption{Syntax of ISWIM}
\label{fig:syntax}
\end{figure}

\begin{figure}
\[
\begin{array}{l@{\qquad}rcl}
\text{Values} & \mval   &=& \clos{\mvar,\mexp,\menv}\ |\ \mlit\ |\ \mkont\\
\text{States} & \mstate &=& \ev{\mexp,\menv,\msto,\mkont}\\
                       &&|& \co{\mkont,\mval,\msto}\\
                       &&|& \ap{\mval,\mval,\msto,\mkont}\\
\text{Continuations} & \mkont &=& \kmt\\
&&|& \kfn{\mval,\maddr}\\
&&|& \kar{\mexp,\menv,\maddr}\\
&&|& \kif{\mexp,\mexp,\menv,\maddr}\\
\text{Environments} &\menv&\in& \mathit{Var} \rightharpoonup \mathit{Addr}\\
\text{Stores} &\msto&\in& \mathit{Addr} \rightharpoonup \mathcal{P}(\mathit{Value})
\end{array}
\]
\caption{Abstract machine components}
\label{fig:domains}
\end{figure}


The semantics are defined in terms of a machine model.  The machine
components are defined in figure~\ref{fig:domains} and
figure~\ref{fig:aam} defines the transition relation.  The evaluation
of a program is defined as the set of states reachable by the
reflexive, transitive closure of the machine transition relation.  The
machine is a very slight variation on a standard abstract machine for
ISWIM in ``eval, continue, apply'' form~\cite{dvanhorn:Danvy:DSc}.  It
can be systematically derived from a definitional interpreter through
a continuation-passing style transformation and defunctionalization,
or from a structural operational semantics using the refocusing
construction of Danvy and
Nielsen~\cite{dvanhorn:Danvy-Nielsen:RS-04-26}.

Compared with the standard machine semantics, this definition is
different in the following ways, which make it abstractable as a
program analyzer:
\begin{itemize}
\item the store maps addresses to \emph{sets} of values, not
  single values,
\item continuations are heap-allocated, not stack-allocated,
\item there are ``contour values'' (written $\mcntr$) and syntax
  labels ($\mlab$) threaded through the computation, and
\item the machine is implicitly parameterized by the functions
  $\mathit{push}$, $\mathit{bind}$, and $\interpdelta$.
\end{itemize}

\begin{figure}
\begin{gather*}
\begin{align*}
\eval(\mexp) &= \{ \mstate\ |\ \ev[^{\mtcntr}]{\mexp,\varnothing,\varnothing,\kmt} \multimachstep \mstate \} \text{ where }
\end{align*}
\\[2mm]
\begin{array}{@{}r@{\ }c@{\ }l@{}}
%% EVAL
\ev{\svar\mvar,\menv,\msto,\mkont} &\machstep&
\co{\mkont,\mval,\msto}
\text{ where }\mval \in \msto(\menv(\mvar))
\\
\ev{\slit\mlit,\menv,\msto,\mkont} &\machstep&
\co{\mkont,\mlit,\msto}
\\
\ev{\slam\mvar\mexp,\menv,\msto,\mkont} &\machstep&
\co{\mkont,\clos{\mvar,\mexp,\menv},\msto}
\\
\ev[^\mcntr]{\sapp[^\mlab]{\mexpi0}{\mexpi1},\menv,\msto,\mkont} &\machstep&
\ev[^\mcntr]{\mexpi{0},\menv,\msto',\kar[_\mlab^\mcntr]{\mexpi{1},\menv,\maddr}}
\\
&&
\text{ where }\maddr,\msto' = \mathit{push}^\mcntr_\mlab(\msto,\mkont)
\\
\ev[^\mcntr]{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2},\menv,\msto,\mkont} &\machstep&
\ev[^\mcntr]{\mexpi0,\menv,\msto',\kif[^\mcntr]{\mexpi1,\mexpi2,\menv,\maddr}}
\\
&&
\text{ where }\maddr,\msto' = \mathit{push}_\mlab^\mcntr(\msto,\mkont)
\\[2mm]
%% CONTINUE
\co{\kmt,\mval,\msto} &\machstep&
\ans{\msto,\mval}
\\
\co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr},\mval,\msto} & \machstep&
\ev[^\mcntr]{\mexp,\menv,\msto,\kfn[^\mcntr_\mlab]{\mval,\maddr}}
\\
\co{\kfn[^\mcntr_\mlab]{{\mvalx{u}},\maddr},\mval,\msto} & \machstep&
\ap[^\mcntr_\mlab]{\mvalx{u},\mval,\mkont,\msto}
\text{ where }\mkont \in \msto(\maddr)
\\
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\strue,\msto} & \machstep&
\ev[^\mcntr]{\mexpi0,\menv,\msto,\mkont}
\text{ where }\mkont\in\msto(\maddr)
\\
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\sfalse,\msto} & \machstep&
\ev[^\mcntr]{\mexpi1,\menv,\msto,\mkont}
\text{ where }\mkont\in\msto(\maddr)
\\[2mm]
%% APPLY
\ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mval,\msto,\mkont} & \machstep&
\ev[^{\mcntr'}\!]{\mexp,\menv',\msto',\mkont}
\\
\multicolumn{3}{r@{}}{
\text{ where }\menv',\msto',\mcntr' = \mathit{bind\,}^{ \mcntr}_\mlab(\menv,\msto,\mvar,\mval)}
\\
\ap[^\mcntr_\mlab]{\mop,\mval,\msto,\mkont} & \machstep&
\co{\mkont,\mval',\msto}
\text{ where } \mval'\in\interpdelta(\mop,\mval)
\end{array}
\end{gather*}
\caption{Abstract abstract machine for ISWIM}
\label{fig:aam}
\end{figure}


\paragraph{Concrete interpretation} To characterize concrete interpretation, set the implicit
parameters of the relation given in figure~\ref{fig:aam} as follows:
\begin{align*}
\mathit{push}_\mlab^\mcntr(\msto,\mkont) &= \maddr,\msto\sqcup[\maddr\mapsto\{\mkont\}]
\mbox{ where }\maddr \notin\msto
\\
\mathit{bind}_\mlab^\mcntr(\menv,\msto,\mvar,\mval) &= \menv[\mvar\mapsto\maddr],\msto\sqcup[\maddr\mapsto\{\mval\}]
\mbox{ where }\maddr \notin\msto
\end{align*}
The resulting relation is non-deterministic in its choice of
addresses, however it must always choose a fresh address when
allocating a continuation or variable binding.  If we consider machine
states equivalent up to consistent renaming and fix an allocation
scheme, this relation defines a deterministic machine (the relation is really a function).

The interpretation of primitive operations is defined by setting
$\interpdelta$ as follows:
\begin{align*}
\mnum+1 &\in \interpdelta(\saddone,\mnum) &
\mnum-1 &\in \interpdelta(\ssubone,\mnum)\\
\strue &\in \interpdelta(\szerohuh,\szero) &
\sfalse &\in \interpdelta(\szerohuh,\mnum)\text{ if }\mnum\neq \szero\\
\end{align*}


\paragraph{Abstract interpretation} To characterize abstract interpretation, set the implicit
parameters just as above, but drop the $\maddr \not\in \msto$
condition.  This family of interpreters is also non-deterministic in
choices of addresses, but it is free to choose addresses that are
already in use.  Consequently, the machines may be non-deterministic
when multiple values reside in a store location.

It is important to recognize from this definition that \emph{any}
allocation strategy is an abstract
interpretation~\cite{dvanhorn:Might2009Posteriori}.  In particular,
concrete interpretation is a kind of abstract interpretation.  So is
an interpretation that allocates a single cell into which all bindings
and continuations are stored.  On the one hand is an abstract
interpretation that is non-computable and gives only the ground truth
of a programs behavior; on the other is an abstract interpretation
that is easy to compute but gives little information.  Useful program
analyses lay somewhere in between and can be characterized by their
choice of address representation and allocation strategy.  Uniform
\(k\)-CFA~\cite{dvanhorn:nielson-nielson-popl97} is one such analysis.

\paragraph{Uniform \(k\)-CFA} To characterize uniform \(k\)-CFA, set the allocation
strategy as follows, for a fixed constant \(k\):

\begin{align*}
\mathit{push}_\mlab^\mcntr(\msto,\mkont) &=
  \mlab\mcntr,\msto\sqcup[\mlab\mcntr\mapsto\{\mkont\}] \\
\mathit{bind}^\mcntr_\mlab(\menv,\msto,\mvar,\mval) &= \menv[\mvar \mapsto \maddr],
                                           \msto\sqcup[\maddr \mapsto
                                             \{ \mval\}],
                                           \mcntr' \\
\mbox{where } \mcntr' &= \lfloor\mlab\mcntr\rfloor_k \\
              \maddr &= x\mcntr' \\
%%              \lfloor \mtcntr \rfloor_k &= \mtcntr \\
              \lfloor \mcntr \rfloor_0 &= \mtcntr \\
              \lfloor \mlab\mcntr \rfloor_{k+1} &= \mlab\lfloor \mcntr\rfloor_k
\end{align*}
where $\sqcup$ on stores is a point-wise lifting of $\sqcup$: $\msto
\sqcup \msto' = \lambda \maddr. \msto(\maddr) \sqcup \msto'(\maddr)$.
The \(\lfloor\cdot\rfloor_k\) notation denotes the truncation of a list
of symbols to the leftmost \(k\) symbols.

All that remains is the interpretation of primitives.  For abstract
interpretation, we set $\interpdelta$ to the function that returns
$\sNum$ on all inputs---a symbolic value we interpret as denoting the
set of all integers.

At this point, we have abstracted the original machine to one which
has a finite state space for any given program, and thus forms the
basis of a sound, computable program analyzer for ISWIM.

\section{Reduction semantics to baseline analyzer}
\label{sec:baseline}

The uniform $k$-CFA allocation strategy would make $\eval$ in figure
\ref{fig:aam} a computable abstraction of reachable states, but not an
efficient one. This is not the strategy that AAM, nor we, recommend. Through
this and the following section, we will explain a succession of approximations
to reach the baseline analysis.  We'll compare performance at each stage to
identify the criticality of each optimization. 
%
We ground this journey by first formulating the analysis in terms of a classic
fixed-point computation.


\subsection{Static analysis as fixed-point computation}
\label{sec:fixpoint}

Conceptually, the AAM approach calls for computing an analysis as a graph
exploration: (1) start with an initial state, and (2) compute the transitive
closure of the transition relation from that state.

We can cast this exploration process in terms of a fixed-point calculation.
%
Given the initial state $\varsigma_0$ and the transition relation $\machstep$,
we define the global transfer function:
\begin{equation*}
 F_{\varsigma_0} : \mathcal{P}(\mathit{State}) \to \mathcal{P}(\mathit{State})
 \text.
\end{equation*}
Internally, this global transfer function computes the successors of all supplied states, and then includes the initial state:
\begin{equation*}
  F_{\varsigma_0}(S) = \{ \varsigma_0 \} \cup \{ \varsigma' \mathrel{|} \varsigma \in S \text{ and } \varsigma \machstep \varsigma' \}\text. 
\end{equation*}
Then, the evaluator for the analysis computes the least fixed-point of the global transfer function:
\begin{equation*}
 \eval(e) = \mathrm{lfp}(F_{\varsigma_0})\text{,}
\end{equation*}
where $\varsigma_0 = \ev[^\mtcntr]{e, \varnothing, \varnothing, \kmt}$.


To conduct this \naive{} exploration on the \Church{} example would require
considerable time.  Even though the state space is finite, it is exponential in
the size of the program.  Even with $k = 0$, there are exponentially many
stores in the AAM framework.

In the next subsection, we'll fix this with a widening and reach polynomial
(albeit of a high degree) complexity.
%
This widening effectively lifts the store out of individual states to create
a single, global shared store for all.


\subsection{Store widening}
\label{sec:storewiden}

A common technique to accelerate convergence in flow analyses is to share a
common, global store.
%
To retain soundness, this store grows monotonically.
%
Formally, we can cast this optimization as a second abstraction or as the
application of a widening operator during the fixed-point iteration.
%
In the ISWIM language, such a widening makes 0-CFA quartic in the size of the
program.
%
Thus, in one step, complexity drops from intractable exponentially to a merely
daunting polynomial.

Since we can cast this optimization as a widening, there is no need to change
the transition relation itself.
%
Rather, what changes is the structure of the fixed-point iteration.
%
In each pass, the algorithm will collect all newly produced stores and join
them together.
%
Then, before each transition, it will install this joined store into current
state.

To describe this process, we'll refactor the transition relation so that it operates on
a pair of a set of contexts ($C$) and a store ($\sigma$).
%
A context includes all non-store components, \emph{e.g.}, the expression, the environment and the stack.
%
The refactored relation, $\widehat{\machstep}$, becomes:
%
\begin{align*}
(C, \msto) &\mathrel{\widehat{\machstep}} (C', \msto') \\
\mbox{where } C' &= \{c' \mid \wn(c, \msto) \mathrel{\machstep} \wn(c', \msto^c), c \in C\} \\
              \msto' &= \bigsqcup\; \{\msto^c \mid \wn(c,\msto)\mathrel{\machstep} \wn(c', \msto^c), c \in C\} \\
\wn(\ev{\mexp, \menv, \mkont}, \msto) &= \ev{\mexp, \menv, \msto, \mkont} \\
\wn(\co{\mval, \mkont}, \msto) &= \co{\mval, \msto, \mkont} \\
\wn(\ap{\mvalx{u}, \mval, \mkont}, \msto) &= \ap{\mvalx{u}, \mval, \msto, \mkont} \\
\wn(\ans{\mval}, \msto) &= \ans{\msto, \mval}
\end{align*}
%
In effect, the new store is computed as the least upper bound of all stores after stepping.


\subsection{Store-allocated results}
\label{sec:baselineeval}

The final approximation we make to get to our point of departure is
store-allocating results of application sub-expressions. 
The AAM approach stops at the previous optimization. 
However, the {\tt fn} continuation stores a value, and this makes the space of
continuations quadratic rather than linear in the size of the program---even for a monovariant analysis like 0CFA.
Having the space of continuations grow linearly with the size of the program 
will drop the overall complexity to cubic (as expected).

To achieve this linearity for continuations, we allocate an address
for the value position when we create the continuation.  This address
and the tail address are both determined by the label of the
application point, so the space becomes linear and the overall
complexity drops to cubic.  This is a critical abstraction in
languages with $n$-ary functions, since otherwise the continuation
space grows super-exponentially. In our example language, we have only
unary functions, so application forms always have two positions: the
function and the argument. Thus for every application labeled $\mlab$,
we introduce two new labels, $\mlab^f$ and $\mlab^a$.
% In theory, this aggressive distinction between continuations might buy
% additional precision, but in practice, it does not.

In $k$-CFA, the evaluation rules become:

\newcommand{\ext}[3]{#1\sqcup[#2\mapsto#3]}
%\newcommand{\ext}[3]{ext(#1,#2,#3)}

\begin{align*}
%ext(\msto, \maddr, s) &= \msto \sqcup [\maddr \mapsto s] \\
\ev[^\mcntr]{\sapp[^\mlab]{\mexpi0}{\mexpi1},\menv,\msto,\mkont} &\machstep
\ev[^\mcntr]{\mexpi{0},\menv,\ext{\msto}{\mlab}{\{\mkont\}},\kar{\mexpi{1},\menv,\mlab,\mcntr}}
\\
\co{\kar{\mexp,\menv,\mlab,\mcntr},\mval,\msto} & \machstep
\ev[^\mcntr]{\mexp,\menv,\ext{\msto}{\mlab^f\mcntr}{\{\mval\}},\kfn{\mlab^f,\mlab,\mcntr}}
\\
\co{\kfn{\mlab^f,\mlab,\mcntr},\mval,\msto} & \machstep
\ap[^\mcntr_\mlab]{\mvalx{u},\mlab^a,\mkont,\ext{\msto}{\mlab^a\mcntr}{\{\mval\}}}
\\
\text{ where } &\mkont \in \msto(\mlab\mcntr), \mvalx{u} \in \msto(\mlab^f\mcntr)
\\
\ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mlab^a, \msto,\mkont} & \machstep
\ev[^{\mcntr'}]{\mexp,\menv[\mvar\mapsto\mvar\mcntr'],\ext{\msto}{\mvar\mcntr'}{\msto(\mlab^a\mcntr)},\mkont}
\\
\text{ where }& \mcntr' = \lfloor\mlab\mcntr\rfloor_k
\\
\ap[^\mcntr_\mlab]{\mop,\mlab^a,\msto,\mkont} & \machstep
\co{\mkont,\mval',\msto}
\\
\text{ where }& \mval'\in \{\interpdelta(\mop,\mval) \mid \mval \in \msto(\mlab^a\mcntr)\}
\end{align*}

% This extra store-allocation is effectively naming all intermediate
% results, and thus the precision aligns with an analysis specialized to
% ANF. We can also play a representation trick in 0-CFA and remove
% $\menv$. In monovariant analyses, variables map to themselves, meaning
% $\menv$ is effectively the identity function. That degeneration, in
% turn, allows us to discard it from the analysis.

% Wide Store: cpu time: 551571 real time: 571319 gc time: 4003

\section{Implementation techniques}
\label{sec:opt}

In this section, we discuss the optimizations for abstract interpreters that
yield our ultimate performance gains.
%
We have two broad categories of these optimizations: (1) transition elimination
and (2) pragmatic improvement.
%
The transition-elimination optimizations reduce the overall number of transitions
made by the analyzer by performing:
\begin{enumerate}
 \item lazy non-determinism;
 \item abstract compilation; and
 \item uniform literal approximation.
\end{enumerate}
The pragmatic improvements reduce overhead and trade space for time
by utilizing:
\begin{enumerate}
 \item store deltas;
 \item timestamped stores; and
 \item preallocated data structures.
\end{enumerate}

Some techniques preserve the precision of the underlying analysis, and others
do not.
%
For any technique that loses precision, we will discuss the design rationale
for the move.


\subsection{Lazy non-determinism}

Tracing the execution of the analysis reveals an immediate shortcoming:
there is a high degree of branching and merging in the exploration.
%
Surveying this branching has no benefit for precision.
%
For example, in a function application, {\tt (f x y)},
where {\tt f}, {\tt x} and {\tt y} each have several values
each argument evaluation induces two-way branching, only to be ultimately joined back together in their respective
application positions. 
%
Transition patterns of this shape litter the state-graph:
%
\begin{center}
\includegraphics[scale=0.3]{fanout}
\end{center}
To avoid the spurious forking and joining, we {\it delay} the non-determinism
until and unless it is needed in {\it strict contexts} (such as the guard for an
{\tt if} a called procedure, or a numerical primitive application). 
%
Doing so collapses these forks and joins into a linear sequence of states:
\begin{center}
\includegraphics[scale=0.3]{lazy}
\end{center}

This shift does not change the concrete semantics of the language to
be lazy.  Rather, it abstracts over transitions that the original
non-deterministic semantics steps through.
%
We say the abstraction is \emph{lazy} because it delays dereferencing an
address until its contents are \emph{needed} as values in the semantics. It
does not change the execution order that leads to the values that are stored in
the address.

We introduce a new kind of value, $\saddr{\maddr}$, that represents a
delayed lookup of $\maddr$.  The following rules highlight the
changes to the semantics:

\renewcommand{\ext}{\mathit{ext}}

\begin{align*}
\force &: \Store \times \Value \to \Set(\Value) \\
\force(\msto,\saddr\maddralt) &= \msto(\maddralt)\\
\force(\msto,\mval) &= \{\mval\} \\
\ext(\msto, \maddr, \mval) &= \msto \sqcup[\maddr \mapsto \force(\msto, \mval)] \\
\ev{\svar{\mvar},\menv,\mkont,\msto} &\machstep\;
\co{\mkont,\saddr{\menv(\mvar)},\msto} \\
\co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr},\mval,\msto}
&\machstep\;
\ev[^\mcntr]{\mexp,\menv,\ext(\msto, \maddr^f,\mval),\kfn[^\mcntr_\mlab]{\maddr^f,\maddr}} \\
\mathit{bind\,}^\mcntr_\mlab(\menv,\msto,\mvar,\mval) &= \menv[\mvar \mapsto
  \maddr], \ext(\msto,\maddr, \mval), \mcntr' \\
\mbox{where } \mcntr' &= \lfloor\mlab\mcntr\rfloor_k \\
              \maddr &= \mvar\mcntr'
\end{align*}

\noindent
We have two choices for how to implement lazy non-determinism.

\paragraph{Option 1: Lose precision; simplify implementation}
This semantics introduces a subtle precision difference over the
baseline. Consider a configuration where a reference to a variable and
a binding of a variable will happen in one step. With laziness, the
reference will mean the original binding(s) of the variable or the new
one, because the actual store lookup is delayed one step
(i.e. laziness is administrative). Without laziness, the reference
will fan out to all the bindings of the variable before the new
binding happens and thus might have an observable precision
difference.

\paragraph{Option 2: Regain precision; complicate implementation}
The administrative nature of laziness means that we could remove the
loss in precision by duplicating the reduction relation to specialize
variable lookup. This works since in the semantics of ISWIM with
store-allocated results consumes the value component of states in one
step. This is not the case for semantics that replicate the value
component across reductions, say for popping off exception handler
frames. Further convolution is needed to remove the administrative
nature of laziness in these semantics. Due to the increase of
conceptual complexity for negligible benefit, we decided against this
approach.

\paragraph{Our choice: option 1}
The configurations that lead to precision loss happen too rarely to
warrant the significant increase in time and memory needed for this
eager non-determinism. Indeed, were the variable reference a step
later and another binding not made in that step, the results of the
two approaches are the same.

% Lazy:  cpu time: 32481 real time: 32881 gc time: 547

\subsection{Abstract compilation}

The prior optimization saved time by doing the same amount of
reasoning as before but in fewer transitions. We can exploit the same
idea---same reasoning, fewer transitions---with abstract
compilation. Abstract compilation is \emph{precision-preserving} and
transforms complex expressions whose \emph{abstract} evaluation is
deterministic into ``abstract bytecodes.''  The abstract interpreter
then does in one transition what previously took many. In short, abstract
compilation eliminates unnecessary allocation, deallocation and
branching.

The following example illustrates
the essence of abstract compilation effect:
\[
\sapp{\sapp{\sapp\mvar{\mexp_1}}{\mexp_2}}{\mexp_3}
\]
makes the following transitions:
\begin{align}
& \ev{\sapp{\sapp{\sapp\mvar{\mexp_1}}{\mexp_2}}{\mexp_3},\menv,\mkont,\msto_0}\\
\machstep\; &
\ev{\sapp{\sapp\mvar{\mexp_1}}{\mexp_2},\menv,\kar{\mexp_3,\menv,\maddr_1},\msto_1}
\\
\machstep\; &
\ev{\sapp\mvar{\mexp_1},\menv,\kar{\mexp_2,\menv,\maddr_2},\msto_2}
\\
\machstep\; &
\ev{\mvar, \menv,\kar{\mexp_1,\menv,\maddr_3},\msto_3} % {\mexp_2}
\\
\machstep\; &
\co{\kar{\mexp_1,\menv},\mval,\msto_4} % {\mexp_1}{\mexp_2}
\mbox{ where } \mval \in \msto(\menv(\maddr))
\end{align}
where \(
\msto_4 = \msto_0 \sqcup \{ [\maddr_1 \mapsto \{ \mkont \}],
[\maddr_2 \mapsto \kar{\mexp_3,\menv,\maddr_1}],
[\maddr_3 \mapsto \kar{\mexp_2,\menv,\maddr_2}]\).


The compilation step converts expressions into functions that expect
the other components of the {\tt ev} state. Its definition in figure
\ref{fig:compile} shows close similarity to the rules for interpreting
    {\tt ev} states. The next step is to change reduction rules that
    create {\tt ev} states to instead call these functions. Figure
    \ref{fig:caam} shows the modified reduction relation.

\begin{figure}
\begin{align*}
\compile{\_} &: \Expr \to \Env \times \Store \times \Kont \to \State \\
\compile{\svar\mvar} &= \lambda(\menv,\msto,\mkont) .\co{\mkont,\saddr{\menv(\mvar)},\msto}
\\
\compile{\slit\mlit} &= \lambda(\menv,\msto,\mkont) .
\co{\mkont,\mlit,\msto}
\\
\compile{\slam\mvar\mexp} &= \lambda(\menv,\msto,\mkont) .
\co{\mkont,\clos{\mvar,\compile\mexp,\menv},\msto}
\\
\compile{\sapp[^\mlab]{\mexpi0}{\mexpi1}} &= \lambda^\mcntr(\menv,\msto,\mkont) .
\compile{\mexpi0}^\mcntr(\menv,\msto',\kar[_\mlab^\mcntr]{\compile{\mexpi1},\menv,\maddr})
\\
&
\text{ where }\maddr,\msto' = \mathit{push}^\mcntr_\mlab(\msto,\mkont)
\\
\compile{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2}} &= \lambda^\mcntr(\menv,\msto,\mkont) .
\compile{\mexpi0}^\delta(\menv,\msto',\kif[^\mcntr]{\compile{\mexpi1},\compile{\mexpi2},\menv,\maddr})
\\
&\text{ where }\maddr,\msto' = \mathit{push}_\mlab^\mcntr(\msto,\mkont)
\end{align*}
\caption{Abstract compilation}
\label{fig:compile}
\end{figure}

\begin{figure}
\begin{gather*}
\begin{align*}
\mathit{eval}(\mexp) &= \{ \mstate\ |\ \compile{\mexp}(\epsilon,\varnothing,\varnothing,\kmt) \multimachstep \mstate \} \text{ where }
\end{align*}
\\[2mm]
\begin{align*}
%% CONTINUE
\co{\kmt,\mval,\msto} &\machstep
\ans{\msto,\mval}
\\
\co{\kar[^\mcntr_\mlab]{\mcomp,\menv,\maddr},\mval,\msto} & \machstep
\mcomp^\mcntr(\menv,\msto,\kfn[^\mcntr_\mlab]{\mval,\maddr})
\\
\co{\kfn[^\mcntr_\mlab]{{\mvalx{u}},\maddr},\mval,\msto} & \machstep
\ap[^\mcntr_\mlab]{\mval,\mvalx{u},\mkont,\msto}
\text{ where }\mkont \in \msto(\maddr)
\\
\co{\kif[^\mcntr]{\mcompi0,\mcompi1,\menv,\maddr},\strue,\msto} & \machstep
\mcompi0^\mcntr(\menv,\msto,\mkont)
\text{ where }\mkont\in\msto(\maddr)
\\
\co{\kif[^\mcntr]{\mcompi0,\mcompi1,\menv,\maddr},\sfalse,\msto} & \machstep
\mcompi1^\mcntr(\menv,\msto,\mkont)
\text{ where }\mkont\in\msto(\maddr)
\\[2mm]
%% APPLY
\ap[^\mcntr_\mlab]{\clos{\mvar,\mcomp,\menv},\mval,\msto,\mkont} & \machstep
\mcomp^{\mcntr'}(\menv',\msto',\mkont) \\
\text{ where }\menv',\msto',\mcntr' &= \mathit{bind\,}^{ \mcntr}_\mlab(\menv,\msto,\mvar,\mval)
\\
\ap{\mop,\mval,\msto,\mkont} & \machstep
\co{\mkont,\mval',\msto} \\
\text{ where }\mkont &\in\msto(\maddr)
\text{ and } \mval'\in\interpdelta(\mop,\mval)
\end{align*}
\end{gather*}
\caption{Abstract abstract machine for compiled ISWIM}
\label{fig:caam}
\end{figure}

% Compile: cpu time: 255397 real time: 261532 gc time: 2947

% \noindent
% Compile + Lazy: cpu time: 31173 real time: 31642 gc time: 739

%\newpage

\subsection{Locally log-based store deltas}

Every step the analysis makes for the above techniques requires
joining large stores together. Not every step will modify all
addresses of the store, so joining entire stores is wasteful in terms
of memory and time. We can instead log store changes and replay the
change log on the full store after all steps have completed. This uses
far fewer join operations, leading to less overhead, and is \emph{precision-preserving}.

We represent change logs as $\msdiff \in \StoreDelta = (\Addr \times
  \Set(\Storeable))^*$. Each $\msto\sqcup[\maddr \mapsto \mval{s}]$
 becomes a log addition
$\cons{\ttuple{\maddr}{\mval{s}}}{\msdiff}$, where $\msdiff$ begins
empty ($\mtlst$) for each step. Applying the changes to the full store
is straightforward:
% TODO: Turn the recursion here into ...:
\begin{align*}
\replay &: \StoreDelta \times \Store \to \Store \\
\replay(\mtlst, \msto) &= \msto \\
\replay(\cons{\ttuple{\maddr}{\mval{s}}}{\msdiff}, \msto) &= \replay(\msdiff, \msto\sqcup[\maddr \mapsto \mval{s}])
\end{align*}

The transition relation is identical except for the addition of this change log.
%
Lookups will never rely on the change log, and can use the originally supplied store unmodified:

\begin{align*}
(\ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mval,\mkont},\msto,\msdiff) & \machstep
(\ev[^{\mcntr'}]{\mexp,\menv',\mkont},\msdiff') \\
\text{ where }\menv',\msdiff',\mcntr' &= \mathit{bind\,}^{ \mcntr}_\mlab(\menv,\msto,\msdiff,\mvar,\mval)
\end{align*}
\begin{align*}
\mathit{bind\,}^{\mcntr}_\mlab(\menv, \msto, \msdiff, \mvar, \mval) &= \menv[\mvar \mapsto \maddr], \cons{\ttuple{\maddr}{\force(\msto,\mval)}}{\msdiff}, \mcntr' \\
\text{ where } \mcntr' &= \lfloor \mlab \mcntr\rfloor_k \\
               \maddr &= \mvar\mcntr'
\end{align*}
Compilation changes to additionally take a $\msdiff$ component, so the
above rule's right hand side would instead be $k^{\mcntr'}(\menv',
\msto, \msdiff', \mkont)$ where $k = \compile{e}$ would be in the closure.

We also lift $\machstep$ to accommodate for this asymmetry
in the input and output. For each state that is stepped, we feed the
output changes to the next so that all changes get accumulated:

\begin{align*}
(\states, \msto) &\mathrel{\widehat{\machstep}} (\states\cup \states', \replay(\msdiff,\msto)) \\
\mbox{ where } (\states', \msdiff) &= \step^*(\varnothing, \states, \mtlst) \\
\step^*(S, \varnothing, \msdiff) &= (S, \msdiff) \\
\step^*(S, \{c\}\cup \states, \msdiff &= \step^*(S\cup cs^*, \states, \msdiff^*) \\
\states^* &= \{c' \mid (c,\msto,\msdiff) \machstep (c',\msdiff^c) \} \\
\msdiff^* &= \concat\{\msdiff^c \mid (c, \msto,\msdiff) \machstep (c', \msdiff^c)\}
\end{align*}

Here $\concat : \Set(\StoreDelta) \to \StoreDelta$ flattens the lists
of changes to one; the order in which it appends does not matter:
\begin{align*}
\concat(\varnothing) &= \mtlst \\
\concat(\{\msdiff\}\cup D) &= \append(\msdiff, \concat(D))
\end{align*}

%% Delta Store +k Compile + Lazy:
%%    cpu time: 668 real time: 686 gc time: 41

\subsection{Timestamping an imperative store}

Thus far, we have made our optimizations in a purely functional
manner. For the next series of optimizations, we need to dip into the
imperative. We can motivate this entire sequence of optimizations by
focusing on the largest bottleneck in the current state-space
exploration algorithm: checking to see if a state has already been
seen. Given two states, checking equality is expensive because the
stores within each are large, and every entry must be checked against
every other. Hashes can sometimes rule out inequality relatively
quickly, but the incidence of collisions and actual equality is
costly.

And, there is a better way. Shivers' original work on $k$-CFA was
susceptible to the same problem, and he suggested three complementary
optimizations: (1) make the store global; (2) update the store
imperatively; and (3) associate every change in the store with a
version number -- its timestamp. Then, put timestamps in states
where previously there were stores. Given two states, the analysis can
now compare their stores just by comparing their timestamps -- a
constant-time operation.

There is a subtle loss of precision in Shivers' original time-stamp
technique that we can fix. For a given abstract state, all writes to
the global store need to be delayed until the analysis considers all
branches from that abstract state. This avoids cross-branch pollution
which would not otherwise happen, e.g., when one branch writes to
address $\maddr$ and another branch reads from address
$\maddr$. Fortunately, given our conversion to log-based stores this
change is straightforward.

At this point, we can begin to think of the analysis as an imperative
algorithm with six major components:
%
\begin{itemize}
 \item{$\msto$, the store;}
 \item{{\tt todo}, the workset;}
 \item{{\tt seen}, a map from states to the timestamps at which they were last seen;}
 \item{$\msdiff$, the store changes for the current step;}
 \item{$\changep$, a boolean tracking whether the stepped state contributed a store change; and}
 \item{{\tt T}, the timestamp of the store.}
\end{itemize}

The new $\eval$ calculation is defined in
figure~\ref{fig:imperative}.  To ensure termination, we guard against adding
$c$ to {\tt todo} by the following check:
\begin{align*}\changep \vee {\tt seen}(c) \neq {\tt T}\end{align*}
If it succeeds, {\tt todo} gets $c$ and we update {\tt seen} to map $c$ to {\tt T}.

After all steps complete, we apply $\msdiff$ to $\msto$ imperatively
(with {\tt replay!}) and increase {\tt T} as long as there was at
least one change in $\msdiff$. This logic leads to termination if we
know that each $\ttuple{\maddr}{\mval{s}}$ in $\msdiff$ would change
the value of $\maddr$ in the current store. Thus, we also guard
additions to $\msdiff$ so that only updates that would change the
store are permitted. Each time $\msdiff$ is successfully extended, we
set $\changep$ to true. Before each individual step, we set it
to false.

\begin{figure}
\begin{alltt}
eval(\(e\)) :=
  \(\msto\), todo, seen, T := \(\varnothing\), \(\varnothing\), [], 0
  \(\compile{e}\)(\(\mtcntr, \varnothing, \varnothing, \mtlst, \kmt\))
  while(true):
    if todo = \(\varnothing\): return (keys(seen), \(\msto\))
    else:
      let old := todo
      todo, \(\msdiff\) := \(\varnothing\), \(\mtlst\)
      foreach c \(\in\) old: \(\changep\) := false; c()
      unless \(\msdiff\) = \(\mtlst\): T += 1; replay!(\(\msdiff, \msto\))
\end{alltt}
\caption{Imperative algorithm}
\label{fig:imperative}
\end{figure}

\subsection{Pre-allocating the store}

Internally, the algorithm at this stage uses hash tables to model the store.
%
This is because stores used to be distributed to all states, which
required a compact, dynamic representation.
%
But, such a dynamic structure isn't necessary when we know the
structure of the store in advance: we know all possible entries, and
we know its maximum size.

In a monovariant analysis, the domain of the store is
exactly the set of expressions in the program.
%
If we label each expression with a unique natural, the analysis can
index directly into the store without a hash or a collision.
%
Even for polyvariant analyses, it is possible to compute the maximum
number of addresses and similarly pre-allocate either the spine of the
store or (if memory is no concern) the entire store.

\subsection{Abstracting literal compound data}

The abstraction of compound data structures like lists has deep implications 
for precision and performance.
%
The classic list-heavy benchmark {\tt boyer}---a simplified implementation
of the Boyer-Moore theorem-prover---drove our own considerations for
abstractions for compound data structures.
%
Boyer's fluent use of literal list dooms the ``natural'' abstraction
of lists to fail from over precision.
%
In short, if we interpret a literal list {\tt '(a b c)} as {\tt (cons 'a (cons 'b
(cons 'c '())))}, even a monovariant allocation strategy for abstract
cons cells will precisely and exactly create a 3-cell list.

If code contains a length-300 literal list, then its analysis yields a length-300 abstract
list as well.
%
In many cases, the specific contents of the list add little precision
to the resulting analysis, and yet the analyzer will dutifully execute
recursive functions over the entirety of these structures at every
encounter.
%
An alternative in this case is to explicitly flatten literal lists
into single abstract cells.

We explore both options here.
%
We will first explain the natural abstraction of tuples, and then we
will explain a less precise allocation strategy from uniform $k$-CFA
that we use for large compound data literals that we modified from the
implementation in \citep{dvanhorn:wright-jagannathan-toplas98}.

\subsubsection{Option 1: The natural abstraction}

The uniform way AAM approaches a simple abstraction strategy is to cut
recursion out of the data definition by tying the recursive knot
through the abstract store. For Scheme, the grammar for values looks
like the following:

\newcommand{\alt}{\;\mid\;}
\begin{align*}
\Value &::= \mbox{{\tt \#t}} \alt \mbox{{\tt \#f}} \alt \mbox{{\tt(cons $\Value$ $\Value$)}} \alt \mbox{{\tt '()}} \alt ...
\end{align*}

Upon evaluating a {\tt cons} application, we instead allocate two
addresses $a$ and $d$, join them to the respective values in the
store, and return the flattened {\tt (cons $a$ $d$)} value. Since
these addresses are all distinguished at different syntactic call sites
in the uniform $k$-CFA allocation strategy, and quoted lists are sugar
for a sequence of calls to {\tt cons}, this abstraction explodes the
value space. Analyzing a function that counts the number of atoms in a
literal s-expression would actually interpret that function at least
that number of times (more because of intermediate conses). Indeed,
even in our fastest implementation, this abstraction causes the
analysis of Boyer to be 430 times slower than the approach we will now
describe.

\subsubsection{Option 2: A precise yet compact abstraction}

The number of syntactic uses of {\tt cons} versus implicit uses via
literal lists is smaller in typical Scheme programs. We use the above
abstraction for these syntactic uses, but choose to interpret literal
lists as not always sugar for cascading {\tt cons}es. In particular,
if a list literal is ``too big'' (in our case length $>$ 1), we
interpret the list as a circular data structure; the right address
points back to the {\tt cons} itself, and the left address points to
all of the elements of the list. We take this farther and join the
list elements together in with a coarse type-based abstraction. In
effect, large lists or vectors of literal numbers become unbounded
lists/vectors of ``number.'' Heterogeneous data is combined to just
``data,'' rather than a union of ``number'', ``string'', etc. since
primitives are interpreted on every combination of values that flow to
them, and unions lead to more primitive interpretations.

Quotation is special because it cannot introduce function values,
which is important for a simple semantics. If we join two values of
different type together, we don't get ``anything,'' which has complex
meaning in higher-order languages (Shivers' escape semantics) and is
overly approximate. We instead get ``any quotable value,'' which has
much simpler semantics.

There are a few steps to consider:
\begin{itemize}
 \item{Define special value lattice elements for compound data domains that can be quoted
       (e.g. {\tt QPair} for $\left\{ ({\tt cons}\ a_i\ d_i)\right\}_i$, {\tt QVector} for immutable vectors, etc.)}
 \item{Define a ``larger'' value lattice element for all quotable data, {\tt QData}}
 \item{Interpret {\tt (quote (a ...))} as {\tt (qlist a ...)}, a new primitive function defined in figure \ref{fig:qlist},
       and similar definitions for immutable vectors.}
 \item{Extend the $\interpdelta$ axioms to include conservative
   meaning for these new values (e.g. {\tt (car QData)} = {\tt QData},
   {\tt (add1 QData)} = {\tt Number} and log ``possible type error'')
   and allow them to allocate addresses and change the store}
\end{itemize}

\begin{figure}
\begin{align*}
\interpdelta(\msto,\ {\tt qlist}) &= (\mbox{{\tt '()}}, \msto) \\
\interpdelta(\msto,\ {\tt qlist}, v ..._+) &= (({\tt cons}\ a\ d), \msto') \\
\qquad \mbox{where } \msto' &= \msto\sqcup[a \mapsto \bigsqcup(v ...)] \\
                            &\qquad \sqcup[d \mapsto \{ \mbox{{\tt '()}}, ({\tt cons}\ a\ d)\}] \\
\bigsqcup(v) &= v \\
\bigsqcup(v, vs ...) &= \fmerge(v, \bigsqcup(vs ...)) \\
\fmerge(v, v) &= v \\
\fmerge(n, m) &= {\tt Number} \\
\fmerge(n, v) &= {\tt QData} \\
\fmerge(({\tt cons}\ a\ d), ({\tt cons}\ a'\ d')) &= {\tt QPair} \\
\fmerge({\tt QPair}, ({\tt cons}\ a\ d)) &= {\tt QPair} \\
\fmerge({\tt QPair}, v) &= {\tt QData} \\
\vdots
\end{align*}
\caption{Quoted list primitive}
\label{fig:qlist}
\end{figure}

This abstraction was so critical to timely convergence that all of our evaluation uses it.

\section{Evaluation}
\label{sec:eval}

We have implemented, optimized, and evaluated an analysis framework
supporting higher-order functions, state, first-class control,
compound data, and a large number of primitive kinds of data and
operations such as floating point, complex, and exact rational
arithmetic.  The analysis is evaluated against a suite of Scheme benchmarks
drawn from the literature.
%
For each benchmark, we collect analysis times, peak memory usage, and
the rate of states-per-second explored by the analysis for each of the
optimizations discussed in section~\ref{sec:opt}, cumulatively
applied.  The analysis is stopped after consuming 30 minutes of time
or 1 gigabyte of space.  When presenting \emph{relative} numbers, we
use the timeout limits as a lower bound on the actual time required,
thus giving a conservative estimate of improvements.

All benchmarks are calculated as an average of 5 runs, done in
parallel, on an 12-core, 64-bit Intel Xeon machine running at 2.40GHz
with 12Gb of memory.

Many benchmarks cause the baseline analyzer to take longer than 30
minutes or to consume more 1 gigabyte of memory, at which point the
analysis is stopped.  This is the case for the largest benchmark
program, {\bf nucleic}, which is 3,500 lines of code and takes under a minute in the
most optimized analyzer.  For those benchmarks that did complete on
the baseline, the optimized analyzer outperformed the baseline by a
factor of two to three orders of magnitude.
% safer to not give exact factors
% 475 to 4,382.

We use the following set of benchmarks:
\begin{figure}
\centering
\include{bench-overview}
\caption{Overview performance comparison between baseline and
  optimized analyzer (entries of \text{{\small $t$}} mean timeout, and \text{{\small $m$}} mean out of memory).}
\label{fig:bench-overview}
\end{figure}

\begin{enumerate}  %% Maybe use ``dictionary'' style enumeration.

\item {\bf nucleic}: a floating-point intensive application taken from
  molecular biology that has been used widely in benchmarking
  functional language
  implementations~\cite{dvanhorn:Hartel1996Benchmarking} and analyses
  (e.g.~\cite{dvanhorn:wright-jagannathan-toplas98,dvanhorn:jagannathan-etal-popl98}).
  It is a constraint satisfaction algorithm used to determine the
  three-dimensional structure of nucleic acids.

\item {\bf matrix} tests whether a matrix is maximal among all
  matrices of the same dimension obtainable by simple reordering of
  rows and columns and negation of any subset of rows and columns.  It
  is written in continuation-passing style (used in
  \cite{dvanhorn:wright-jagannathan-toplas98,dvanhorn:jagannathan-etal-popl98}).


\item {\bf nbody}: implementation~\cite{ianjohnson:nbody87} of the
  Greengard multipole algorithm for computing gravitational forces on
  point masses distributed uniformly in a cube (used in
  \cite{dvanhorn:wright-jagannathan-toplas98,dvanhorn:jagannathan-etal-popl98}).

\item {\bf earley}: Earley's parsing algorithm, applied to a 15-symbol
  input according to a simple ambiguous grammar.  A real program,
  applied to small data whose exponential behavior leads to a peak
  heap size of half a gigabyte or more during concrete execution.

\item {\bf maze}: generates a random maze using Scheme's {\tt
  call/cc} operation and finds a path solving
  the maze (used in
  \cite{dvanhorn:wright-jagannathan-toplas98,dvanhorn:jagannathan-etal-popl98}).

\item {\bf church}: tests distributivity of multiplication over
  addition for Church numerals (introduced by
  \cite{dvanhorn:Vardoulakis2011CFA2}).

\item {\bf lattice}: enumerates the order-preserving maps between two
  finite lattices (used in
  \cite{dvanhorn:wright-jagannathan-toplas98,dvanhorn:jagannathan-etal-popl98}).

\item {\bf boyer}: a term-rewriting theorem prover (used in
  \cite{dvanhorn:wright-jagannathan-toplas98,dvanhorn:jagannathan-etal-popl98}).

\item {\bf mbrotZ}: generates Mandelbrot set fractal using complex
  numbers.

\item {\bf graphs}: counts the number of directed graphs with a
  distinguished root and \(k\) vertices, each having out-degree at
  most 2. It is written in a continuation-passing style and makes
  extensive use of higher-order procedures---it creates closures
  almost as often as it performs non-tail procedure calls (used by
  \cite{dvanhorn:wright-jagannathan-toplas98,dvanhorn:jagannathan-etal-popl98}).
\end{enumerate}

%% 400 lines for the core, 700 lines for
%% abstraction over optimizations, 1500 lines for primitives and standard
%% list operations, 700 lines for instantiations to different
%% optimizations and 300 for parsing and macro transformers.

Figure~\ref{fig:bench-overview} gives an overview of the benchmark
results in terms of absolute time, space, and speed between the
baseline and most optimized analyzer.  Figure~\ref{fig:bench-all}
plots the factors of improvement over the baseline for each
optimization step. The dip we see in transition rate even though time
taken decreases is to be expected - fewer ``easy'' states are added by
abstract compilation. It increases again with the introduced
algorithmic improvements. Accumulating store changes in addition to
maintaining the store accounts for the higher memory usage when using
the store delta technique without further improvements.

\begin{figure*}
\begin{center}
  \includegraphics[width=6.5in]{all-relative-space}

  (a) Peak memory usage

  \vspace{1em}
  \includegraphics[width=6.5in]{all-relative-speed}

  (b) Rate of state transitions

  \vspace{1em}
  \includegraphics[width=6.5in]{all-relative-time}

  (c) Total analysis time
\end{center}
\caption{Factors of improvement over baseline for each step of
  optimization (bigger is better).}
\label{fig:bench-all}
\end{figure*}

Source code of the implementation and benchmark suite is at:

\begin{center}
\url{https://github.com/dvanhorn/oaam}
\end{center}

\paragraph{Comparison with other flow analysis implementations}

The analysis considered here computes results similar to Earl, et al.'s
0-CFA implementation~\cite{dvanhorn:Earl2012Introspective}, which
times out on the \Church{} benchmark because it does not widen the
store as described for our baseline evaluator.  So even though it
offers a fair point of comparison, a more thorough evaluation is
probably uninformative as the other benchmarks are likely to timeout
as well (and it would require significant effort to extend their
implementation with the features needed to analyze our benchmark
suite).  That implementation is evaluated against much smaller
benchmarks: the largest program is 30 lines.

Vardoulakis and Shivers evaluate their CFA2
analyzer~\cite{dvanhorn:Vardoulakis2011CFA2} against a variant of
0-CFA defined in their framework and the example we draw on is the
largest benchmark Vardoulakis and Shivers consider.  More work would
be required to scale the analyzer to the set of features required by
our benchmarks.

The only analyzers we were able to find that proved capable of
analyzing the full suite of benchmarks considered here were the Soft
Typing system of Wright and
Cartwright~\cite{dvanhorn:Wright1997Practical} and, in many ways its
successor, the Polymorphic splitting system of Wright and
Jagannathan~\cite{dvanhorn:wright-jagannathan-toplas98}.\footnote{This
  is not a coincidence; these papers set a high standard for
  evaluation, which we consciously aimed to approach.}  Unfortunately, these
analyses compute an inherently different and incomparable form of
analysis.  Consequently, we have omitted a complete comparison with
these implementations,.  The AAM approach provides more precision in
terms of temporal-ordering of program states, which comes at a cost
that can be avoided in constraint-based approaches.  Consequently
implementation techniques cannot be ``ported'' between these two
approaches.  However, our optimized implementation is within an order
of magnitude of the performance of Wright and Jaganathan's analyzer.
Although we would like to improve this to be more competitive, the
optimized AAM approach still has many strengths to recommend it in
terms of precision, ease of implementation and verification, and rapid
design.




\section{Related work}
\label{sec:related}

\paragraph{Abstracting Abstract Machines}

This work clearly closely follows Van Horn and Might's original papers
on abstracting abstract
machines~\cite{dvanhorn:VanHorn2011Abstracting,dvanhorn:VanHorn2012Systematic},
which in turn is one piece of the large body of research on flow
analysis for higher-order languages (see
Midtgaard~\cite{dvanhorn:Midtgaard2011Controlflow} for a thorough
survey).  The AAM approach sits at the confluence of two major lines
of research: (1) the study of abstract
machines~\cite{dvanhorn:landin-64} and their systematic
construction~\cite{dvanhorn:reynolds-hosc98}, and (2) the theory of
abstract interpretation
\cite{dvanhorn:Cousot:1977:AI,dvanhorn:Cousot1979Systematic}.


\paragraph{Frameworks for flow analysis of higher-order programs}

Besides the original AAM work, the analysis most similar to that
presented in section~\ref{sec:aam} is the infinitary control-flow
analysis of Nielson and Nielson~\cite{dvanhorn:nielson-nielson-popl97}
and the unified treatment of flow analysis by Jagannathan and
Weeks~\cite{dvanhorn:jagannathan-weeks-popl95}.  Both are
parameterized in such a way that in the limit, the analysis is
equivalent to an interpreter for the language, just as is the case
here.  What is different is that both give a constraint-based
formulation of the abstract semantics rather than a finite machine
model.

\paragraph{Abstract compilation}

Boucher and Feeley \cite{dvanhorn:Boucher1996Abstract} introduced the
idea of \emph{abstract compilation}, which used closure generation
\cite{dvanhorn:Feeley1987Using} to improve the performance of control
flow analysis.  We have adapted the closure generation technique from
composition evaluators to abstract machines and applied it to similar
effect.

\paragraph{Constraint-based program analysis for higher-order languages}

Constraint-based program analyses
(e.g.~\cite{dvanhorn:nielson-nielson-popl97,dvanhorn:wright-jagannathan-toplas98,dvanhorn:Meunier2006Modular,dvanhorn:steckler-wand-toplas97})
typically compute sets of abstract values for each program point.
These values approximate values arising at run-time for each
program point.  Value sets are computed as the least solution to a set
of (inclusion or equality) constraints.  The
constraints must be designed and proved as a sound approximation of
the semantics.  Efficient implementations of these kinds of analyses
often take the form of worklist-based graph algorithms for constraint
solving, and are thus quite different from the interpreter
implementation.  The approach thus requires effort in constraint
system design and implementation, and the resulting system require
verification effort to prove the constraint system is sound and that
the implementation is correct.

This effort increases substantially as the complexity of the analyzed
language increases.  Both the work of maintaining the concrete
semantics and constraint system (and the relations between them) must
be scaled simultaneously.  However, constraint systems, which have
been extensively studied in their own right, enjoy efficient
implementation techniques and can be expressed in declarative logic
languages that are heavily
optimized~\cite{dvanhorn:bravenboer-smaragdakis-oopsla09}.
Consequently, constraint-based analyses can be computed quickly.  For
example, Jagannathan and Wright's polymorphic splitting
implementation~\cite{dvanhorn:wright-jagannathan-toplas98} analyses
the \Church{} benchmark about 25 times faster than the fastest
implementation considered here.  These analyses compute very different
things, so the performance comparison is not apples-to-apples.

The AAM approach, and the state transition graphs it generates, encodes
temporal properties not found in classical constraint-based analyses
for higher-order programs.
%
These analyses (ultimately) compute judgments on program terms and
contexts, e.g., at expression $e$, variable $x$ may have value $v$.
%
The judgments do not relate the order in which expressions and context
may be evaluated in a program, e.g., it has nothing
to say with regard to question like, ``Do we always evaluate $e_1$
before $e_2$?'' or ``Is it always the case that a file handle is
opened, read and then closed in that order?''
%
The state transition graphs can answer these kinds of queries, but
this does not come for free: respecting temporal order imposes an
order in which states and terms may be evaluated \emph{during} the
analysis.

We view the primary contribution of this work as a systematic path
that eases the design, verification, and implementation of analyses
using the abstracting abstract machine approach to within a factor of
performant constraint-based analyses.

\section{Conclusion}
\label{sec:conclusion}

Abstract machines are not only a good model for rapid analysis
development, they can be systematically developed into efficient
algorithms.

%% \acks Sam Tobin-Hochstadt for encouragement and feedback -- he was
%% the first to prompt us to look into how make effective
%% implementations of the AAM approach.

%% Vincent St Amour for feedback on early drafts.
%% Greg Morrisset and Matthias Felleisen for discussions.

%% NSF, DARPA


\paragraph{Acknowledgments}

We thank Suresh Jagannathan for providing source code to the
polymorphic splitting
analyzer~\cite{dvanhorn:wright-jagannathan-toplas98} and Ilya Sergey
for the introspective pushdown
analyzer~\cite{dvanhorn:Earl2012Introspective}.


\balance
\bibliographystyle{plain}
\input{paper.bbl}
%\bibliography{local,bibliography}

% \include{appendix}

\end{document}
