\documentclass{llncs}
\usepackage{amsmath,amssymb,pfsteps,multicol,stmaryrd,mathpartir,centernot}
\input{preamble}

\newcommand{\nequiv}{\centernot\equiv}
\newcommand{\finto}{\mathbin{\overset{\text{fin}}{\rightharpoonup}}}

\newcommand{\dom}{\mathbf{dom}}
\newcommand{\length}{\mathit{length}}
\newcommand{\cyclefree}{\mathit{cycle\text{-}free}}
\newcommand{\prop}{\mathit{prop}}
\newcommand{\lengthF}{{\mathcal F}}
\newcommand{\klength}{\mathit{klength}}
\newcommand{\possibletrace}{\mathit{possible\text{-}trace}}
\newcommand{\buildtable}{\mathit{build\text{-}table}}
\newcommand{\buildtablefrom}{\mathit{bt}}
\newcommand{\buildkont}{\mathit{build\text{-}kont}}
\newcommand{\reverse}{\mathit{reverse}}

\newcommand{\absN}{\hat{{\mathbb N}}}
\newcommand{\absn}{\hat{n}}
\newcommand{\squish}{\mathbin{\otimes}}

\newcommand{\many}[1]{\overline{#1}}

\newcommand{\var}{x}
\newcommand{\app}[2]{(#1\ #2)}
\newcommand{\lam}[2]{\lambda\ #1.\ #2}
\newcommand{\closure}[3]{(\lambda #1. #2,\ #3)}

\newcommand{\expr}{e}

\newcommand{\addr}{a}

\newcommand{\ktab}{\Xi}
\newcommand{\ktabof}{\mathit{KTable\text{-}of}}
\newcommand{\Ktab}{\mathit{KTable}}
\newcommand{\Kkey}{\mathit{KTableKey}}
\newcommand{\ktabkey}[3]{(#1,\ #2,\ #3)}
\newcommand{\ktabentry}[2]{(#1,\ #2)}

\newcommand{\val}{v}

\newcommand{\kont}{\kappa}

\newcommand{\env}{\rho}

\newcommand{\sto}{\sigma}

\newcommand{\conf}{\varsigma}
\newcommand{\Conf}{\mathit{Conf}}

\newcommand{\redto}{\mathbin{\longmapsto}}
\newcommand{\redtraceto}[1][\ ]{\mathbin{\longmapsto^{TR}_{#1}}}

\newcommand{\alt}{\mid}
\newcommand{\mt}{\mathbf{mt}}
\newcommand{\ar}[3]{\mathbf{ar}(#1,\ #2,\ #3)}
\newcommand{\fn}[2]{\mathbf{fn}(#1,\ #2)}
\newcommand{\rt}[2]{\texttt{[]}^{(#1,\ #2)}}

\begin{document}

For reasons of space, the entire definitions of each intermediate
semantics were not shown (just the original and lazy, abstractly
compiled). We thus give a reference here to the complete semantics of
each other machine to use as a basis for the following proofs.

\section{Semantics}

\subsection{ISWIM with store-allocated results}

Machine configuration space:
\begin{align*}
\mstate \in \State &= \ev[^\mcntr]{\mexp, \menv, \msto, \mkont} \alt
                     \co{\mkont, \mval, \msto} \alt
                     \ap[_\mlab^\mcntr]{\mval,\maddr,\msto,\mkont} \alt
                     \ans{\msto,\mval} \\
\mkont \in \Kont &::= \kmt \alt
                      \kar[_\mlab^\mcntr]{\mexp, \menv, \maddr,\maddr,\maddr} \alt
                      \kfn[_\mlab^\mcntr]{\maddr, \maddr, \maddr} \alt
                      \kif[_\mlab^\mcntr]{\mexp, \mexp, \menv, \mkont} \\
\mlab \in \Label &\text{ an infinite set} \\
\mval \in \Value &::= \mlit \alt \mop \alt
                      \clos{\mvar,\mexp,\menv} \\
\mstor \in \Storeable &::= \mlit \alt \mop \alt
                           \clos{\mvar,\mexp,\menv} \alt
                           \mkont \\
\menv \in \Env &= \Var \finto \Addr \\
\msto \in \Store &= \Addr \finto \wp(\Storeable)
\end{align*}

Reduction semantics:
\begin{gather*}
\begin{array}{@{}r@{\ }c@{\ }l@{}}
%% EVAL
\ev{\svar\mvar,\menv,\msto,\mkont} &\machstep&
\co{\mkont,\mval,\msto} \text{ if } \mval \in \msto(\menv(\mvar))
\\
\ev{\slit\mlit,\menv,\msto,\mkont} &\machstep&
\co{\mkont,\mlit,\msto}
\\
\ev{\slam\mvar\mexp,\menv,\msto,\mkont} &\machstep&
\co{\mkont,\clos{\mvar,\mexp,\menv},\msto}
\\
\ev[^\mcntr]{\sapp[^\mlab]{\mexpi0}{\mexpi1},\menv,\msto,\mkont} &\machstep&
\ev[^\mcntr]{\mexpi{0},\menv,\msto',\kar[_\mlab^\mcntr]{\mexpi{1},\menv,\maddr_\mkont}}
\\
&&
\text{ where }\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont) \\
&&\phantom{\text{ where }}\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]
\\
\ev[^\mcntr]{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2},\menv,\msto,\mkont} &\machstep&
\ev[^\mcntr]{\mexpi0,\menv,\msto',\kif[^\mcntr]{\mexpi1,\mexpi2,\menv,\maddr}}
\\
&&
\text{ where }\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont) \\
&&\phantom{\text{ where }}\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]
\\[2mm]
%% CONTINUE
\co{\kmt,\mval,\msto} &\machstep&
\ans{\msto,\mval}
\\
\co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr_\mkont},\mval,\msto} & \machstep&
\ev[^\mcntr]{\mexp,\menv,\msto',\kfn[^\mcntr_\mlab]{\maddr_f,\maddr_\mkont}}
\\
&&
\text{ where }
\begin{array}{ll}
 \maddr_f &= \alloc(\mstate) \\
 \msto' &= \msto\sqcup[\maddr_f \mapsto \{\mval\}]
\end{array}
\\
\co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr_\mkont},\mval,\msto} & \machstep&
\ap[^\mcntr_\mlab]{\mvalx{u},\mval,\mkont,\msto}
\text{ where } \mkont \in \msto(\maddr_\mkont), \mvalx{u} \in \msto(\maddr_f)
\\
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\strue,\msto} & \machstep&
\ev[^\mcntr]{\mexpi0,\menv,\msto,\mkont}
\text{ where }\mkont\in\msto(\maddr)
\\
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\sfalse,\msto} & \machstep&
\ev[^\mcntr]{\mexpi1,\menv,\msto,\mkont}
\text{ where }\mkont\in\msto(\maddr)
\\[2mm]
%% APPLY
\ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mval,\msto,\mkont} & \machstep&
\ev[^{\mcntr'}\!]{\mexp,\menv',\msto',\mkont}
\\
\multicolumn{3}{r@{}}{
\text{ where }
\begin{array}{ll}
 \maddr &= \alloc(\mstate) \\
 \menv' &= \menv[\mvar \mapsto \maddr] \\
 \msto' &= \msto\sqcup[\maddr \mapsto\{\mval\}]
\end{array}}
\\
\ap[^\mcntr_\mlab]{\mop,\mval,\msto,\mkont} & \machstep&
\co{\mkont,\mval',\msto}
\text{ where } \mval'\in\interpdelta(\mop,\mval)
\end{array}
\end{gather*}

\begin{align*}
\inject(\mexp) &= \ev[^\mtcntr]{\mexp,\bot,\bot,\kmt} \\
\reachable{\mexp} &= \setof{\mstate \mid \inject(\mexp) \machstep^* \mstate}
\end{align*}

\subsection{Store-allocated results with lazy nondeterminism}

Machine configuration space:
\begin{align*}
\mstate \in \State &= \ev[^\mcntr]{\mexp, \menv, \msto, \mkont} \alt
                     \co{\mkont, \mval, \msto} \alt
                     \ap[_\mlab^\mcntr]{\mval,\mval,\msto,\mkont} \alt
                     \ans{\msto,\mval}\\
\mval \in \Value &::= \mlit \alt \mop \alt
                      \clos{\mvar,\mexp,\menv} \alt
                      \spchoice{\saddr\maddr}{\superposition{\mval{s}}}
\end{align*}
$\Kont$, $\Storeable$, $\Env$ and $\Store$ are defined the same as previously.

Reduction semantics:
\begin{gather*}
\begin{array}{@{}r@{\ }c@{\ }l@{}}
%% EVAL
\ev{\svar\mvar,\menv,\msto,\mkont} &\machstep&
\co{\mkont, \spchoice{\saddr{\menv(\mvar)}}{\superposition{\msto(\menv(\mvar))}},\msto}
\\
\ev{\slit\mlit,\menv,\msto,\mkont} &\machstep&
\co{\mkont,\mlit,\msto}
\\
\ev{\slam\mvar\mexp,\menv,\msto,\mkont} &\machstep&
\co{\mkont,\clos{\mvar,\mexp,\menv},\msto}
\\
\ev[^\mcntr]{\sapp[^\mlab]{\mexpi0}{\mexpi1},\menv,\msto,\mkont} &\machstep&
\ev[^{\mcntr'}]{\mexpi{0},\menv,\msto',\kar[_\mlab^\mcntr]{\mexpi{1},\menv,\maddr}}
\\
&&
\text{ where }\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont) \\
&&\phantom{\text{ where }}\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]
\\
\ev[^\mcntr]{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2},\menv,\msto,\mkont} &\machstep&
\ev[^{\mcntr'}]{\mexpi0,\menv,\msto',\kif[^\mcntr]{\mexpi1,\mexpi2,\menv,\maddr}}
\\
&&
\text{ where }\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont) \\
&&\phantom{\text{ where }}\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]
\\[2mm]
%% CONTINUE
\co{\kmt,\mval,\msto} &\machstep&
\ans{\msto,\mvalx{u}}
\text{ where } \mvalx{u} \in \spchoice{\force(\msto, \mval)}{\force(\mval)}
\\
\co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr},\mval,\msto} & \machstep&
\ev[^{\mcntr'}]{\mexp,\menv,\msto',\kfn[^\mcntr_\mlab]{\maddr_f,\maddr}}
\\
&&
\text{ where }
\begin{array}{ll}
 \maddr_f &= \alloc(\mstate)\\
 \msto' &= \msto\sqcup[\maddr_f\mapsto\spchoice{\force(\msto,\mval)}{\force(\mval)}]
\end{array}
\\
\co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr},\mval,\msto} & \machstep&
\ap[^{\mcntr'}_\mlab]{\mvalx{u},\mval,\mkont,\msto}
\text{ where } \mkont \in \msto(\maddr), \mvalx{u} \in \msto(\maddr_f)
\\
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\strue,\msto} & \machstep&
\ev[^{\mcntr'}]{\mexpi0,\menv,\msto,\mkont}
\text{ where }\mkont\in\msto(\maddr)
\\
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\sfalse,\msto} & \machstep&
\ev[^{\mcntr'}]{\mexpi1,\menv,\msto,\mkont}
\text{ where }\mkont\in\msto(\maddr)
\\[2mm]
%% APPLY
\ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mval,\msto,\mkont} & \machstep&
\ev[^{\mcntr'}\!]{\mexp,\menv',\msto',\mkont}
\\
\multicolumn{3}{r@{}}{
\text{ where }
\begin{array}{ll}
 \maddr &= \alloc(\mstate) \\
 \menv' &= \menv[\mvar \mapsto \maddr] \\
 \msto' &= \msto\sqcup[\maddr \mapsto \spchoice{\force(\msto, \mval)}{\force(\mval)}]
\end{array}}
\\
\ap[^\mcntr_\mlab]{\mop,\mval,\msto,\mkont} & \machstep&
\co{\mkont,\mval',\msto}
\text{ where } \mvalx{u} \in \spchoice{\force(\msto, \mval)}{\force(\mval)}, \mval'\in\interpdelta(\mop,\mvalx{u})
\end{array}
\end{gather*}

\begin{align*}
\spchoice
{\force(\msto,\saddr\maddr) &= \msto(\maddr) \\
 \force(\msto,\mval) &= \{ \mval \}}
{\force(\superposition{\mval{s}}) &= \mval{s} \\
 \force(\mval) &= \{ \mval \}}
\end{align*}

\begin{align*}
\inject(\mexp) &= \ev[^\mtcntr]{\mexp,\bot,\bot,\kmt} \\
\reachable{\mexp} &= \setof{\mstate \mid \inject(\mexp) \machstep^* \mstate}
\end{align*}

\subsection{Lazy nondeterminism with abstract compilation}

Machine configuration space:
\begin{align*}
\mstate \in \State &= \co{\mkont, \mval, \msto} \alt
                     \ap[_\mlab^\mcntr]{\mval,\mval,\msto,\mkont} \alt
                     \ans{\msto, \mval}\\
\mcomp \in \Compiled &= (\Env \times \Store \times \Kont \times \Counter) \to \State \\
\mkont \in \Kont &::= \kmt \alt
                      \kar[_\mlab^\mcntr]{\mcomp, \menv, \maddr} \alt
                      \kfn[_\mlab^\mcntr]{\maddr, \maddr} \alt
                      \kif[_\mlab^\mcntr]{\mcomp, \mcomp, \menv, \maddr} \\
\mval \in \Value &::= \mlit \alt \mop \alt
                      \clos{\mvar,\mcomp,\menv} \alt
                      \spchoice{\saddr\maddr}{\superposition{\mval{s}}}
\spchoice{\\}{\\\mval{s} \in \wp(\Value)\\}
\Storeable &::= \mlit \alt \mop \alt
                \clos{\mvar,\mcomp,\menv} \alt
                \mkont \\
\end{align*}
$\Store$ and $\Env$ are defined the same as previously.

We write $\lambda^\mcntr(\mathit{args}\ldots). \mathit{body}$ (and without superscript) to mean
$\lambda(\mathit{args}\ldots \mcntr). \mathit{body}$ and
$\mcomp^\mcntr(\menv, \msto, \mkont)$ to mean $\mcomp(\menv, \msto,
\mkont, \mcntr)$ for notational consistency.

Abstract compilation function:

\begin{align*}
\compile{\_} &: \Expr \to \Compiled \\
\compile{\svar\mvar} &= \lambda(\menv,\msto,\mkont) .
                          \co{\mkont, \spchoice{\saddr{\menv(\mvar)}}{\superposition{\msto(\menv(\mvar))}},\msto}
\\
\compile{\slit\mlit} &= \lambda(\menv,\msto,\mkont) .
\co{\mkont,\mlit,\msto}
\\
\compile{\slam\mvar\mexp} &= \lambda(\menv,\msto,\mkont) .
\co{\mkont,\clos{\mvar,\compile\mexp,\menv},\msto}
\\
\compile{\sapp[^\mlab]{\mexpi0}{\mexpi1}} &= \lambda^\mcntr (\menv,\msto,\mkont) .
\compile{\mexpi0}^{\mcntr'}(\menv,\msto',\kar[_\mlab^\mcntr]{\compile{\mexpi1},\menv,\maddr})
\\
&
\text{ where }\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont) \\
&\phantom{\text{ where }}\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]
\\
\compile{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2}} &= \lambda^\mcntr(\menv,\msto,\mkont) .
\compile{\mexpi0}^{\mcntr'}(\menv,\msto',\kif[^\mcntr]{\compile{\mexpi1},\compile{\mexpi2},\menv,\maddr})
\\
\text{ where }\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont) \\
&\phantom{\text{ where }}\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]
\end{align*}

Reduction semantics:

\begin{gather*}
\begin{align*}
%% CONTINUE
\co{\kmt,\mval,\msto} &\machstep
\ans{\msto,\mvalx{u}}
\text{ where } \mvalx{u} \in \spchoice{\force(\msto,\mval)}{\force(\mval)}
\\
\co{\kar[^\mcntr_\mlab]{\mcomp,\menv,\maddr},\mval,\msto} & \machstep
\mcomp^\mcntr(\menv,\msto',\kfn[^\mcntr_\mlab]{\maddr_f,\maddr})
\\
\text{ where }\maddr_f &= \alloc(\mstate) \\
              \msto' &= \msto\sqcup[\maddr_f \mapsto \spchoice{\force(\msto,\mval)}{\force(\mval)}]
\\
\co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr},\mval,\msto} & \machstep
\ap[^\mcntr_\mlab]{\mvalx{u},\mval,\msto,\mkont}
\text{ where } \mkont \in \msto(\maddr), \mvalx{u} \in \msto(\maddr_f)
\\
\co{\kif[^\mcntr]{\mcompi0,\mcompi1,\menv,\maddr},\strue,\msto} & \machstep
\mcompi0^\mcntr(\menv,\msto,\mkont)
\text{ where }\mkont\in\msto(\maddr)
\\
\co{\kif[^\mcntr]{\mcompi0,\mcompi1,\menv,\maddr},\sfalse,\msto} & \machstep
\mcompi1^\mcntr(\menv,\msto,\mkont)
\text{ where }\mkont\in\msto(\maddr)
\\[2mm]
%% APPLY
\ap[^\mcntr_\mlab]{\clos{\mvar,\mcomp,\menv},\mval,\msto,\mkont} & \machstep
\mcomp^{\mcntr'}(\menv',\msto',\mkont) \\
\text{ where }
\maddr &= \alloc(\mstate) \\
\menv' &= \menv[\mvar \mapsto \maddr] \\
\msto' &= \msto\sqcup[\maddr \mapsto \spchoice{\force(\msto, \mval)}{\force(\mval)}]
\\
\ap{\mop,\mval,\msto,\mkont} & \machstep
\co{\mkont,\mval',\msto} \\
\text{ where }\mkont &\in\msto(\maddr)
\text{ and } \mvalx{u} \in \spchoice{\force(\msto,\mval)}{\force(\mval)}, \mval'\in\interpdelta(\mop,\mvalx{u})
\end{align*}
\end{gather*}

\begin{align*}
\inject(\mexp) &= \compile{\mexp}^{\mtcntr}(\bot,\bot,\kmt) \\
\reachable{\mexp} &= \setof{\mstate \mid \inject(\mexp) \machstep^* \mstate}
\end{align*}

\subsection{Widened abstract compilation}

%\spchoice{
Machine configuration space:
\begin{align*}
\mstate \in \State &= \co{\mkont, \mval} \alt
                     \ap[_\mlab^\mcntr]{\mval,\mval,\mkont} \alt
                     \ans{\mval} \\
\System &= (\wp(\State \times \Store) \setminus \setof{\varnothing}) \times \wp(\State) \times \Store
\end{align*}

\begin{align*}
\nw(\co{\mkont,\mval,\msto}) &= \co{\mkont, \mval}, \msto \\
\nw(\ap[^\mcntr_\mlab]{\mvalx{u},\mval,\msto,\mkont}) &= \ap[^\mcntr_\mlab]{\mvalx{u},\mval,\mkont}, \msto \\
\nw(\ans{\msto,\mval}) &= \ans{\mval}, \msto \\
\wn(\co{\mkont,\mval},\msto) &= \co{\mkont,\mval,\msto} \\
\wn(\ap[^\mcntr_\mlab]{\mvalx{u},\mval,\mkont},\msto) &= \ap[^\mcntr_\mlab]{\mvalx{u},\mval,\msto,\mkont} \\
\wn(\ans{\mval},\msto) &= \ans{\msto,\mval}
\end{align*}

Reduction semantics:
\begin{align*}
\inject(\mexp) &= (\setof{\ttuple{\mstate'}{\msto}},\setof{\mstate'},\msto) \\
 \text{ where } \mstate &= \compile{\mexp}^{\mtcntr}(\bot,\bot,\kmt) \\
                \mstate', \msto &= \nw(\mstate) \\
\reachable{\mexp} &= \setof{\wn(\mstate,\msto') \mid
                             \inject(\mexp) \machstep^* (S,F,\msto),
                             \ttuple{\mstate}{\msto'} \in S} \\
(S,F,\msto) &\machstep (S \cup S', F', \msto') \\
 \text{ where }
  I &= \setof{ \nw(\mstate^*) \mid \mstate \in F, \wn(\mstate,\msto) \machstep \mstate^*, \nw(\mstate^*)\notin S} \\
  F' &= \setof{\mstate \mid \exists \msto. \ttuple{\mstate}{\msto} \in S'} \\
  \Sigma &= \setof{\msto \mid \exists \mstate. \ttuple{\mstate}{\msto} \in S'} \\
  \msto' &= \bigsqcup\limits_{\msto\in\Sigma}{\msto} \\
  S' &= \setof{\ttuple{\mstate}{\msto'} \mid \mstate \in F'}
\end{align*}

% superposition needs an extra step for function application
\spchoice{ }
{
\subsection{Wide abstract compilation with delayed call}

Machine configuration space:
\begin{align*}
\mstate \in \State &= \co{\mkont, \mval} \alt
                      \ap[_\mlab^\mcntr]{\mval,\mval,\mkont} \alt
                      \call[^\mcntr]{\mcomp,\mval,\mkont} \alt
                     \ans{\mval}
\end{align*}

Helper reduction semantics:

\begin{gather*}
\begin{align*}
%% CONTINUE
\co{\kmt,\mval} &\machstep_\msto
\ans{\mvalx{u}},\msto
\text{ where } \mvalx{u} \in \spchoice{\force(\msto,\mval)}{\force(\mval)}
\\
\co{\kar[^\mcntr_\mlab]{\mcomp,\menv,\maddr},\mval} & \machstep_\msto
\mcomp^{\mcntr'}(\menv,\msto',\kfn[^\mcntr_\mlab]{\maddr_f,\maddr})
\\
\text{ where }\maddr_f &= \alloc(\mstate) \\
              \msto' &= \msto\sqcup[\maddr_f \mapsto \spchoice{\force(\msto,\mval)}{\force(\mval)}]
\\
\co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr},\mval} & \machstep_\msto
\ap[^{\mcntr'}_\mlab]{\mvalx{u},\mval,\mkont},\msto
\text{ where } \mkont \in \msto(\maddr), \mvalx{u} \in \msto(\maddr_f)
\\
\co{\kif[^\mcntr]{\mcompi0,\mcompi1,\menv,\maddr},\strue} & \machstep_\msto
\mcompi0^{\mcntr'}(\menv,\msto,\mkont)
\text{ where }\mkont\in\msto(\maddr)
\\
\co{\kif[^\mcntr]{\mcompi0,\mcompi1,\menv,\maddr},\sfalse} & \machstep_\msto
\mcompi1^{\mcntr'}(\menv,\msto,\mkont)
\text{ where }\mkont\in\msto(\maddr)
\\[2mm]
%% APPLY
\ap[^\mcntr_\mlab]{\clos{\mvar,\mcomp,\menv},\mval,\mkont} & \machstep_\msto
%\mcomp^{\mcntr'}(\menv',\msto',\mkont) \\
\call[^{\mcntr'}]{\mcomp, \menv',\mkont},\msto' \\
\text{ where }
\maddr &= \alloc(\mstate) \\
\menv' &= \menv[\mvar \mapsto \maddr] \\
\msto' &= \msto\sqcup[\maddr \mapsto \spchoice{\force(\msto, \mval)}{\force(\mval)}]
\\
\call[^\mcntr]{\mcomp,\menv,\mkont} &\machstep_\msto \mcomp^\mcntr(\menv,\msto,\mkont)
\\
\ap{\mop,\mval,\mkont} & \machstep_\msto
\co{\mkont,\mval'},\msto \\
\text{ where }\mkont &\in\msto(\maddr)
\text{ and } \mvalx{u} \in \spchoice{\force(\msto,\mval)}{\force(\mval)}, \mval'\in\interpdelta(\mop,\mvalx{u})
\end{align*}
\end{gather*}

Reduction semantics:
\begin{align*}
\inject(\mexp) &= (\setof{\ttuple{\mstate'}{\msto}},\setof{\mstate'},\msto) \\
 \text{ where } \mstate', \msto &= \compile{\mexp}^{\mtcntr}(\bot,\bot,\kmt) \\
(S,F,\msto) &\machstep (S \cup S', F', \msto') \\
 \text{ where }
  I &= \setof{ \ttuple{\mstate^*}{\msto'} \mid \mstate \in F, \mstate \machstep_\msto \ttuple{\mstate^*}{\msto'}, \mstate^*\notin S} \\
  F' &= \setof{\mstate \mid \exists \msto. \ttuple{\mstate}{\msto} \in S'} \\
  \Sigma &= \setof{\msto \mid \exists \mstate. \ttuple{\mstate}{\msto} \in S'} \\
  \msto' &= \bigsqcup\limits_{\msto\in\Sigma}{\msto} \\
  S' &= \setof{\ttuple{\mstate}{\msto'} \mid \mstate \in F'}
\end{align*}

}
\subsection{Abstract compilation with store deltas}

All previous machines had a trivial widening operator for the store
that would expand states without stores to states with stores, reduce
with the written semantics, and then remove the resulting stores and
join them again so that there is one store shared amongst all
states. Here we have a different widening that accumulates store
changes so that entire stores need not be joined each step - just
their changes.
\\
Machine configuration space:
\begin{align*}
%\System &= \wp(\State) \times \Store \\
\mstate \in \State &= \co{\mkont, \mval} \alt
                     \ap[_\mlab^\mcntr]{\mval,\mval,\mkont} \alt
\spchoice{ }{\call[^\mcntr]{\mcomp,\menv,\mkont} \alt}
                     \ans{\mval} \\
\mcomp \in \Compiled &=
  (\Env \times \Store \times \StoreDelta \times \Kont \times \Counter) \to
   (\State \times \StoreDelta) \\
\mkont \in \Kont &::= \kmt \alt
                      \kar[_\mlab^\mcntr]{\mcomp, \menv, \maddr} \alt
                      \kfn[_\mlab^\mcntr]{\maddr, \maddr} \alt
                      \kif[_\mlab^\mcntr]{\mcomp, \mcomp, \menv, \maddr} \\
\msdiff \in \StoreDelta &= (\Addr \times \wp(\Storeable))^* %\Addr \finto \wp(\Storeable) \\
\end{align*}
$\Storeable$, $\Store$, $\Env$ and $\Value$ are defined the same as previously.

Abstract compilation function:

\begin{align*}
\dcompile{\_} &: \Expr \to \Compiled \\
\dcompile{\svar\mvar} &= \lambda(\menv,\msto,\msdiff, \mkont) .
                          \ttuple{\co{\mkont, \spchoice{\saddr{\menv(\mvar)}}{\superposition{\msto(\menv(\mvar))}},\msto}}{\bot}
\\
\dcompile{\slit\mlit} &= \lambda(\menv,\msto,\msdiff,\mkont) .
\ttuple{\co{\mkont,\mlit,\msto}}{\bot}
\\
\dcompile{\slam\mvar\mexp} &= \lambda(\menv,\msto,\msdiff,\mkont) .
\ttuple{\co{\mkont,\clos{\mvar,\dcompile\mexp,\menv},\msto}}{\bot}
\\
\dcompile{\sapp[^\mlab]{\mexpi0}{\mexpi1}} &= \lambda^\mcntr (\menv,\msto,\msdiff,\mkont) .
\dcompile{\mexpi0}^{\mcntr'}(\menv,\msto,\msdiff',\kar[_\mlab^\mcntr]{\dcompile{\mexpi1},\menv,\maddr})
\\
&\text{ where }\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont) \\
&\phantom{\text{ where }}\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]
\\
\dcompile{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2}} &= \lambda^\mcntr(\menv,\msto,\msdiff,\mkont) .
\dcompile{\mexpi0}^{\mcntr'}(\menv,\msto,\msdiff',\kif[^\mcntr]{\dcompile{\mexpi1},\dcompile{\mexpi2},\menv,\maddr})
\\
&\text{ where }\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont) \\
&\phantom{\text{ where }}\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]
\end{align*}

Reduction semantics helper (write $\mstate \machstep_\msto \mstate',\msdiff$ to mean $((\mstate,\msto),(\mstate',\msdiff)) \in \machstep$):

\begin{gather*}
\begin{align*}
\machstep &\subseteq (\State \times \Store) \times (\State \times \StoreDelta) \\
%% CONTINUE
\co{\kmt,\mval} &\machstep_\msto
\ans{\mvalx{u}},\bot
\text{ where } \mvalx{u} \in \spchoice{\force(\msto,\mval)}{\force(\mval)}
\\
\co{\kar[^\mcntr_\mlab]{\mcomp,\menv,\maddr},\mval} & \machstep_\msto^\msdiff
\mcomp^\mcntr(\menv,\kfn[^\mcntr_\mlab]{\maddr_f,\maddr}), \msdiff
\\
\text{ where }\maddr_f &= \alloc(\mstate) \\ 
              \msdiff' &= \cons{\ttuple{\maddr_f}{\spchoice{\force(\msto,\mval)}{\force(\mval)}}}{\msdiff}
\\
\co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr},\mval} & \machstep_\msto^\msdiff
\ap[^\mcntr_\mlab]{\mvalx{u},\mval,\mkont}, \msdiff
\text{ where } \mkont \in \msto(\maddr), \mvalx{u} \in \msto(\maddr_f)
\\
\co{\kif[^\mcntr]{\mcompi0,\mcompi1,\menv,\maddr},\strue} & \machstep_\msto^\msdiff
\mcompi0^{\mcntr'}(\menv,\msto,\bot,\mkont), \msdiff
\text{ where }\mkont\in\msto(\maddr)
\\
\co{\kif[^\mcntr]{\mcompi0,\mcompi1,\menv,\maddr},\sfalse} & \machstep_\msto^\msdiff
\mcompi1^{\mcntr'}(\menv,\msto,\bot,\mkont), \msdiff
\text{ where }\mkont\in\msto(\maddr)
\\[2mm]
%% APPLY
\ap[^\mcntr_\mlab]{\clos{\mvar,\mcomp,\menv},\mval,\mkont} & \machstep_\msto^\msdiff
\spchoice
 {\mcomp^{\mcntr'}(\menv',\msto,\msdiff,\mkont), \msdiff'}
 {\call[^{\mcntr'}]{\mcomp,\menv',\mkont}, \msdiff'} \\
\text{ where }
\maddr &= \alloc(\mstate) \\
\menv' &= \menv[\mvar \mapsto \maddr] \\
\msdiff' &= \cons{\ttuple{\maddr}{\spchoice{\force(\msto, \mval)}{\force(\mval)}}}{\msdiff}
\spchoice
 {\\}
 {\\ \call[^\mcntr]{\mcomp,\menv,\mkont} &\machstep_\msto^\msdiff \mcomp^\mcntr(\menv,\msto,\msdiff,\mkont) \\}
\ap{\mop,\mval,\mkont} & \machstep
\co{\mkont,\mval'},\bot \\
\text{ where }\mkont &\in\msto(\maddr)
\text{ and } \mvalx{u} \in \spchoice{\force(\msto,\mval)}{\force(\mval)}, \mval'\in\interpdelta(\mop,\mvalx{u})
\end{align*}
\end{gather*}

Reduction semantics:
\begin{align*}
\inject(\mexp) &= (\setof{\ttuple{\mstate}{\msto}}, \setof{\mstate}, \msto) \\
 \text{ where } \mstate, \msdiff &= \dcompile{e}^{\mtcntr}(\bot,\bot,\bot,\kmt) \\
                \msto &= \replay(\msdiff,\bot) \\
\reachable{\mexp} &= \setof{\wn(\mstate,\msto') \mid
                             \inject(\mexp) \machstep^* (S,F,\msto),
                             \ttuple{\mstate}{\msto'} \in S} \\
(S,F,\msto) &\machstep (S \cup S', F', \msto') \\
 \text{ where }
 (F', \msdiff') &= \step^*(\varnothing, F, \msto, \epsilon) \\
 \msto' &= \replay(\msdiff',\msto) \\
               S' &= \setof{(c,\msto') \mid c \in F'} \\
\step^*(F', \varnothing, \msdiff) &= (F', \msdiff) \\
\step^*(F', \{c\}\cup F, \msdiff) &= \step^*(F'\cup \states^*, F, \msdiff^*) \\
\states^* &= \{c' \mid (c,\msto,\msdiff) \dmachstep (c',\msdiff^c) \} \\
\msdiff^* &= \appendall(\setof{\msdiff^c \mid (c, \msto,\msdiff) \dmachstep (c', \msdiff^c)}) \\
\appendall(\varnothing) &= \epsilon \\
\appendall(\setof{\msdiff}\cup\Xi) &= \append(\msdiff,\appendall(\Xi))
   % I &= \setof{ \ttuple{\mstate'}{\msdiff} \mid \mstate \in F, \mstate \machstep_\msto \mstate', \msdiff} \\
   % F' &= \setof{\mstate \mid \exists \msdiff. \ttuple{\mstate}{\msdiff} \in I} \\
   % \Xi &= \setof{\msdiff \mid \exists \mstate. \ttuple{\mstate}{\msdiff} \in I} \\
   % \msto' &= \replayall(\Xi,\msto) \\
   % S' &= \setof{\ttuple{\mstate}{\msto'} \mid \mstate \in F'} \\
   % \replayall(\varnothing,\msto) &= \msto \\
   % \replayall(\setof{\msdiff} \cup \Xi, \msto) &= \replayall(\Xi, \replay(\msdiff, \msto))
\end{align*}

%% This reduction semantics has an expensive fixed point computation
%% since many states would be stepped several times, even if
%% unnecessary. Instead, we use a frontier solution that maps states to
%% the last store they were processed at to determine if they need to be
%% stepped again.

%% Frontier computation:
%% \begin{align*}
%% \mathit{reachable}(e) &= \lfp{{\mathcal F}}(\varnothing, \setof{\mstate}, \replay(\msdiff,\bot)) \\
%%  \text{ where } \mstate, \msdiff &= \compile{e}^\mcntr(\bot,\bot,\bot,\kmt) \\
%% {\mathcal F} &: ((\State \finto \Store) \times \wp(\State) \times \Store) \to
%%                 ((\State \finto \Store) \times \wp(\State) \times \Store) \\
%% {\mathcal F}(S,F,\msto) &= (S', F \cup F', \msto') \\
%%  \text{ where }
%%   I &= \setof{ \ttuple{\mstate'}{\msdiff} \mid \mstate \in F, \mstate \machstep_\msto \mstate', \msdiff} \\
%%   \msto' &= \replayall(\setof{\msdiff \mid \exists \mstate. (\mstate, \msdiff) \in I}, \msto) \\
%%   F' &= \setof{\mstate \mid \exists \msdiff. (\mstate,\msdiff) \in I,
%%                 \msto' \neq S(\mstate)} \\
%%   S' &= \lambda \mstate. \left\{\begin{array}{ll}
%%                                  \msto' & \text{if } \mstate \in F' \\
%%                                  S(\mstate) & \text{otherwise}
%%                                 \end{array}\right.
%% \end{align*}

\subsection{Store deltas with timestamped store}

\begin{align*}
\inject(\mexp) &=
 (S_0, \setof{\mstate},
  \replay(\msdiff,\bot), 0) \\
 \text{ where } \mstate, \msdiff &= \dcompile{e}^\mcntr(\bot,\bot,\bot,\kmt) \\
                S_0 &= \lambda\mstate'.
                        \left\{\begin{array}{ll}
                         0 & \text{if } \mstate' = \mstate \\
                         \epsilon & \text{otherwise}
                        \end{array}\right. \\
\mathit{reachable}(\mexp) &=
  \setof{\wn(\mstate,\Sigma(n)) \mid
         \inject(\mexp) \machstep^* (S,F,\Sigma,n'), \hd(S(\mstate)) = n}
\end{align*}

\begin{align*}
\System &= (\State \to {\mathbb N}^*) \times \wp(\State) \times \Store^* \times {\mathbb N} \\
(S,F,\Sigma,n) &\machstep (S', F \cup F', \cons{\msto'}{\Sigma},n') \\
 \text{ where }
 \msto &= \hd(\Sigma) \\
  I &= \setof{ \ttuple{\mstate'}{\msdiff} \mid \mstate \in F, \mstate \machstep_\msto \mstate', \msdiff} \\
  \msto',\updatedp &=
     \replaychangeall(\setof{\msdiff \mid \exists \mstate. (\mstate, \msdiff) \in I}, \msto,\sfalse) \\
  n' &= \left\{\begin{array}{ll}
                n + 1 & \text{if } \updatedp \\
                n & \text{otherwise}
               \end{array}\right. \\
  F' &= \setof{\mstate \mid \exists \msdiff. (\mstate,\msdiff) \in I,
                n' \neq \hd(S(\mstate))} \\
  S' &= \lambda \mstate. \left\{\begin{array}{ll}
                                 n' S(\mstate) & \text{if } \mstate \in F' \\
                                 S(\mstate) & \text{otherwise}
                                \end{array}\right.
\end{align*}

\begin{align*}
  \replaychangeall(\setof{\msdiff} \cup \Xi, \msto, \updatedp) &=
    \replaychangeall(\Xi, \msto', \updatedp \vee \joinp) \\
   \text{ where } \msto', \joinp &= \replaychange(\msdiff, \msto, \sfalse) \\
  \replaychangeall(\varnothing, \msto, \updatedp) &= \msto, \updatedp \\
  \replaychange(\msdiff[\maddr \mapsto S], \msto, \joinp) &=
   \replaychange(\msdiff, \msto', \joinp \vee \joinp') \\
  \text{ where } S' &= S \sqcup \msto(\maddr) \\
                 \joinp' &= \msto(\maddr) \deceq S' \\
                 \msto' &= \msto[\maddr \mapsto S'] \\
  \replaychange(\bot, \msto, \joinp) &= \msto, \joinp
\end{align*}

\section{Proofs}

\spchoice{
\subsection{Soundness of lazy-nondeterminism}

\begin{align*}
\alpha(\mstate) &= \mstate \\
\gamma(\ev[^\mcntr]{\mexp, \menv, \msto, \mkont}) &= \setof{\ev[^\mcntr]{\mexp, \menv, \msto, \mkont}} \\
\gamma(\co{\mkont, \mval, \msto}) &= \setof{\co{\mkont, \mval', \msto} \mid \mval' \in \spchoice{\force(\msto,\mval)}{\force(\mval)}} \\
\gamma(\ap[_\mlab^\mcntr]{\mval, \mvalx{u}, \msto}) &= 
   \setof{\ap[_\mlab^\mcntr]{\mval', \mvalx{u}', \msto}
          \mid
          \mval' \in \spchoice{\force(\msto,\mval)}{\force(\mval)},
          \mvalx{u}' \in \spchoice{\force(\msto,\mvalx{u})}{\force(\mvalx{u})}} \\
\gamma(\ans{\msto, \mval}) &= \setof{\ans{\msto, \mval'} \mid \mval' \in \spchoice{\force(\msto,\mval)}msto,{\force(\mval)}} \\
\alpha^*(C) &= \setof{\alpha(\mstate) \mid \mstate \in C} \\
\gamma^*(A) &= \bigcup\limits_{\hat{\mstate} \in A}{\gamma(\hat{\mstate})}
\end{align*}

\begin{mathpar}
\inferrule{\dom(\msto) = \dom(\msto') \\ \forall \maddr. \msto(\addr) \subseteq \msto'(\maddr)}
          {\msto \sqsubseteq \msto'} \\
\inferrule{\msto \sqsubseteq \msto'}
          {\ev[^\mcntr]{\mexp, \menv, \msto, \mkont} \sqsubseteq
           \ev[^\mcntr]{\mexp, \menv, \msto', \mkont}}
 \qquad
\inferrule{\spchoice{\force(\msto, \mval) \subseteq \force(\msto', \mval')}
                    {\force(\mval) \subseteq \force(\mval')}
          \\ \msto \sqsubseteq \msto'}
          {\co{\mkont,\mval,\msto} \sqsubseteq \co{\mkont, \mval', \msto'}} \\
%
\inferrule{\spchoice
           {\force(\msto, \mval) \subseteq \force(\msto', \mval') \\
            \force(\msto, \mvalx{u}) \subseteq \force(\msto', \mvalx{u}')}
           {\force(\mval) \subseteq \force(\mval') \\
            \force(\mvalx{u}) \subseteq \force(\mvalx{u}')}\\
           \msto \sqsubseteq \msto'}
{\ap[_\mlab^\mcntr]{\mval, \mvalx{u}, \msto} \sqsubseteq \ap[_\mlab^\mcntr]{\mval', \mvalx{u}', \msto'}} \\
%
\inferrule{\spchoice
           {\force(\msto, \mval) \subseteq \force(\msto', \mval')}
           {\force(\mval) \subseteq \force(\mval')}
           \\ \msto \sqsubseteq \msto'}
          {\ans{\msto, \mval} \sqsubseteq \ans{\msto', \mval'}}
 \qquad
\inferrule{\forall \hat{\mstate} \in S, \exists \hat{\mstate}' \in S'. \hat{\mstate} \sqsubseteq \hat{\mstate}'}
          {S \sqsubseteq S'}
\end{mathpar}

By definitions of $\alpha, \gamma, \force$, $\gamma^* \circ \alpha^* =
1_C$. Also $\alpha^*\circ\gamma^* \le 1_A$ is straightforward to prove. This forms a Galois connection.

\begin{theorem}If $\mstate \machstep \mstate'$ and $\alpha(\mstate) \sqsubseteq \hat{\mstate}$ then
$\exists \hat{\mstate}'. \hat{\mstate} \machstep \hat{\mstate}'$.
\end{theorem}
\begin{proof}
By assumption, $\gamma^*(\alpha^*(\setof{\mstate})) \sqsubseteq
\gamma^*{\setof{\hat{\mstate}}}$. By the above property, and
definition of $\gamma^*$, $\mstate \in \gamma(\hat{\mstate})$.
Since $\alpha$ does not introduce $\spchoice{\saddr{}}{\superposition{}}$ values, most cases follow by definition.

By cases on $\mstate \machstep \mstate'$:
\begin{byCases}
%% EVAL
\case{\ev{\svar\mvar,\menv,\msto,\mkont} \machstep \co{\mkont,\mval,\msto}}{
 where $\mval \in \msto(\menv(\mvar))$

By assumption, $\hat{\mstate} \equiv \ev{\svar\mvar, \menv, \msto', \mkont}$ such that $\msto \sqsubseteq \msto'$.
\begin{pfsteps*}
 \item{Let $\hat{\mstate}' = \co{\mkont, \spchoice{\saddr{\menv(\mvar)}}{\superposition{\msto(\menv(\mvar))}},\msto'}$}
 \item{$\setof{\mstate'} \sqsubseteq \gamma(\hat{\mstate}')$} \BY{def. $\gamma$}
 \item{$\alpha(\mstate') \sqsubseteq \hat{\mstate}'$} \BY{def. $\alpha$, $\alpha^*\circ\gamma^* \le 1_A$}
\end{pfsteps*}}

\case{\ev{\slit\mlit,\menv,\msto,\mkont} \machstep \co{\mkont,\mlit,\msto}}{
By assumption, $\hat{\mstate} \equiv \ev{\svar\mvar, \menv, \msto', \mkont}$ such that $\msto \sqsubseteq \msto'$.
Let $\hat{\mstate}' = \co{\mkont,\mlit,\msto'}$. Conclusion holds by definition of
$\alpha, \sqsubseteq, \machstep$.}

\case{\ev{\slam\mvar\mexp,\menv,\msto,\mkont} \machstep \co{\mkont,\clos{\mvar,\mexp,\menv},\msto}}{
By assumption, $\hat{\mstate} \equiv \ev{\svar\mvar, \menv, \msto', \mkont}$ such that $\msto \sqsubseteq \msto'$.
Let $\hat{\mstate}' = \co{\mkont,\clos{\mvar,\mexp,\menv},\msto'}$. Conclusion holds by definition of
$\alpha, \sqsubseteq, \machstep$.}

\case{
\ev[^\mcntr]{\sapp[^\mlab]{\mexpi0}{\mexpi1},\menv,\msto,\mkont} \machstep
\ev[^\mcntr]{\mexpi{0},\menv,\msto',\kar[_\mlab^\mcntr]{\mexpi{1},\menv,\maddr}}}{
 where $\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]$

By assumption, $\hat{\mstate} \equiv \ev{\svar\mvar, \menv, \msto^*, \mkont}$ such that $\msto \sqsubseteq \msto^*$.
Let $\hat{\mstate}' = \ev[^\mcntr]{\mexpi{0},\menv,\msto^*_1,\kar[_\mlab^\mcntr]{\mexpi{1},\menv,\maddr}}$ where
$\msto^*_1 = \msto^*[\maddr_\mkont \mapsto \setof{\mkont}]$. Conclusion holds by definition of
$\alpha, \sqsubseteq, \machstep$.}

\case{
\ev[^\mcntr]{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2},\menv,\msto,\mkont} \machstep
\ev[^\mcntr]{\mexpi0,\menv,\msto',\kif[^\mcntr]{\mexpi1,\mexpi2,\menv,\maddr}}}{
 where $\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]$

By assumption, $\hat{\mstate} \equiv \ev{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2},\menv,\msto^*,\kif[^\mcntr]{\mexpi1,\mexpi2,\menv,\maddr}}$ such that $\msto \sqsubseteq \msto^*$.
Let $\hat{\mstate}' = \ev[^\mcntr]{\mexpi0,\menv,\msto^*_1,\kif[^\mcntr]{\mexpi1,\mexpi2,\menv,\maddr}}$
where $\msto^*_1 = \msto^*[\maddr_\mkont \mapsto \setof{\mkont}]$.
Conclusion holds by definition of $\alpha, \sqsubseteq, \machstep$.}

%% CONTINUE
\case{\co{\kmt,\mval,\msto} \machstep \ans{\msto,\mval}}{
By assumption, $\hat{\mstate} \equiv \co{\kmt,\mval',\msto^*}$ where $\msto \sqsubseteq \msto^*$
  and \spchoice{$\force(\msto,\mval) \subseteq \force(\msto^*,\mval')$}
               {$\force(\mval) \subseteq \force(\mval')$}.

By definition of $\force, \sqsubseteq$,  $\mval \in \spchoice{\force(\msto^*,\mval')}{\force(\mval')}$.
Let $\hat{\mstate}' = \ans{\msto^*,\mval}$. Conclusion holds by definition of $\machstep, \force$.}

\case{
\co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr},\mval,\msto} \machstep
\ev[^\mcntr]{\mexp,\menv,\msto',\kfn[^\mcntr_\mlab]{\maddr_f,\maddr}}}{
 where $\maddr_f = \alloc(\mstate),\msto' = \msto\sqcup[\maddr_f \mapsto \spchoice{\force(\msto,\mval)}{\force(\mval)}]$.

\begin{byCases}
\case{\hat{\mstate} \equiv \co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr}, \spchoice{\saddr{\maddrx{c}}}{\superposition{\mval{s}}}, \msto^*}}{
where $\msto \sqsubseteq \msto^*$

Let $\hat{\mstate}' = \ev[^\mcntr]{\mexp,\menv,\msto^*, \kfn[^\mcntr_\mlab]{\maddr_f,\maddr}}$
 where $\maddr_f = \alloc(\mstate), \msto* = \msto\sqcup[\maddr_f\mapsto \spchoice{\saddr{\maddrx{c}}}{\superposition{\mval{s}}}]$. 
Conclusion holds by definition of $\alpha, \sqsubseteq, \machstep$.}

\otherwise{$\hat{\mstate} \equiv \co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr}, \mval, \msto^*}$
 where $\msto \sqsubseteq \msto^*$ and $\mval \nequiv \spchoice{\saddr{\maddrx{c}}}{\superposition{\mval{s}}}$.

Let $\hat{\mstate}' = \ev[^\mcntr]{\mexp,\menv,\msto^*_1,\kfn[^\mcntr_\mlab]{\maddr_f,\maddr}}$
where $\maddr_f = \alloc(\mstate), \msto^*_1 = \msto^*\sqcup[\maddr_f \mapsto \spchoice{\force(\msto, \mval)}{\force(\mval)}]$
Conclusion holds by definition of $\alpha, \sqsubseteq, \machstep$.}
\end{byCases}}

\case{
\co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr},\mval,\msto} \machstep
\ap[^\mcntr_\mlab]{\mvalx{u},\mval,\mkont,\msto}}{
 where $\mkont \in \msto(\maddr), \mvalx{u} \in \msto(\maddr_f)$

By assumption, $\hat{\mstate} \equiv \co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr},\mval',\msto^*}$ where $\msto \sqsubseteq \msto^*$ 
  and $\spchoice{\force(\msto,\mval) \subseteq \force(\msto^*,\mval')}
                {\force(\mval) \subseteq \force(\mval')}$.

By definition of $\sqsubseteq$, $\force$, $\mkont \in \msto^*(\maddr)$ and $\mvalx{u} \in \msto^*(\maddr_f)$. Thus
letting $\hat{\mstate}' = \ap[^\mcntr_\mlab]{\mvalx{u},\mval,\mkont,\msto^*}$. Conclusion holds by definition of $\alpha, \machstep$.}

\case{
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\strue,\msto} \machstep
\ev[^\mcntr]{\mexpi0,\menv,\msto,\mkont}}{
 where $\mkont\in\msto(\maddr)$

By assumption, $\hat{\mstate} \equiv
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\strue,\msto^*}$ where
$\msto \sqsubseteq \msto^*$.

Let $\hat{\mstate}' = \ev[^\mcntr]{\mexpi0,\menv,\msto^*,\mkont}$. Conclusion holds by definition of $\alpha, \machstep$.}

\case{
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\sfalse,\msto} \machstep
\ev[^\mcntr]{\mexpi1,\menv,\msto,\mkont}}{
 where $\mkont\in\msto(\maddr)$

By assumption, $\hat{\mstate} \equiv
\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\sfalse,\msto^*}$ where
$\msto \sqsubseteq \msto^*$.

Let $\hat{\mstate}' = \ev[^\mcntr]{\mexpi1,\menv,\msto^*,\mkont}$. Conclusion holds by definition of $\alpha, \machstep$.}

%% APPLY
\case{
\ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mval,\msto,\mkont} \machstep
\ev[^{\mcntr'}\!]{\mexp,\menv',\msto',\mkont}}{
 where $\maddr = \alloc(\mstate), \menv' = \menv[\mvar \mapsto \maddr],
\msto' = \msto\sqcup[\maddr \mapsto \{\mval\}]$

By assumption, $\hat{\mstate} \equiv
\ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mval',\msto^*,\mkont}$
where $\msto \sqsubseteq \msto^*$ and
 \spchoice{$\force(\msto,\mval) \subseteq \force(\msto^*,\mval')$}
          {$\force(\mval) \subseteq \force(\mval')$}.

Let $\hat{\mstate}' =
\ev[^{\mcntr'}\!]{\mexp,\menv',\msto^*_1,\mkont}$ where
$\menv' = \menv[\mvar \mapsto \maddr], \msto^*_1 = \msto^*\sqcup[\maddr \mapsto \spchoice{\force(\msto, \mval')}{\force(\mval')}]$. 
Conclusion holds by definition of $\alpha, \sqsubseteq, \machstep$.}

\case{
\ap[^\mcntr_\mlab]{\mop,\mval,\msto,\mkont} \machstep
\co{\mkont,\mval',\msto}}{
 where $\mval'\in\interpdelta(\mop,\mval)$

By assumption, $\hat{\mstate} \equiv
\ap[^\mcntr_\mlab]{\mop,\mval^*,\msto^*,\mkont}$ where $\msto \sqsubseteq \msto^*$ 
 and \spchoice{$\force(\msto,\mval) \subseteq \force(\msto^*,\mval^*)$}
              {$\force(\mval) \subseteq \force(\mval^*)$}.
%
By definition of $\force$, $\mval \in \spchoice{\force(\msto^*,\mval')}{\force(\mval')}$. 

Let $\hat{\mstate}' = \co{\mkont, \mval',\msto^*}$. Conclusion holds by definition of $\alpha, \machstep$.}
\end{byCases}
\end{proof}
}
% superpositions give a complete abstraction
{
\subsection{Lazy non-determinism is a complete abstraction}

%% Trivially maintains trace-ness
\newcommand{\Trace}{\mathit{Trace}}
\newcommand{\FullTrace}{\mathit{FullTrace}}
\newcommand{\fulltrace}{\mathit{fulltrace}}
\newcommand{\trunc}{\mathit{trunc}}

First we need some definitions of what are well-formed traces, and
what are well-formed sets of traces. We need well-formed sets of
traces because we need to capture all the non-determinism of the
reduction relation to have sound approximations of concrete traces. We
capture this by saying that if there is a step in a given trace that
could have gone somewhere else, the trace that's the same up to that
step point but takes the different last step must also be in the
set. This generalizes over all the steps in each trace, so all the
non-determinism is guaranteed to be represented in the set of traces.
\begin{align*}
\Trace_{\machstep \subseteq \State \times \State} &=
 \setof{\epsilon} \cup
 \setof{\mstate\ldots\in\State^* \mid \forall 0 \le i < |\mstate\ldots|-1. \mstate_i \machstep \mstate_{i+1}} \\
\FullTrace_{\machstep \subseteq \State \times \State} &=
 \bigcup\limits_{T \subseteq \Trace_{\machstep}}
    \left\{\begin{array}{ll}
            \setof{T} & \text{ if } \fulltrace_{\machstep}(T) \\
            \varnothing & \text{ otherwise}
           \end{array}\right. \\
\fulltrace_{\machstep}(T) &=
  \forall \mstate\ldots\in T. \\
  &\qquad\,\forall 0 \le i < |\mstate\ldots|-1.
     \mstate_i \machstep \mstate_{i+1} \implies \\
   &\qquad\quad\forall \mstate'.(\mstate_i \machstep \mstate' \implies \\
   &\qquad\qquad\quad
       \exists \mstate''\ldots \in T.
         (\forall 0 \le j \le i. \mstate''_j = \mstate_j) \wedge (\mstate''_{i+1} = \mstate')) \\
\end{align*}

\begin{align*}
\gamma &: \State_{\mathit{Lazy}} \mapsto \wp(\State_{\mathit{ISWIM}}) \\
\gamma(\ev[^\mcntr]{\mexp, \menv, \msto, \mkont}) &= \setof{\ev[^\mcntr]{\mexp, \menv, \msto, \mkont}} \\
\gamma(\co{\mkont, \mval, \msto}) &= \setof{\co{\mkont, \mval', \msto} \mid \mval' \in \force(\mval)} \\
\gamma(\ap[_\mlab^\mcntr]{\mval, \mvalx{u}, \msto}) &= 
   \setof{\ap[_\mlab^\mcntr]{\mval', \mvalx{u}', \msto}
          \mid
          \mval' \in \force(\mval),
          \mvalx{u}' \in \force(\mvalx{u})} \\
\gamma(\ans{\msto, \mval}) &= \setof{\ans{\msto, \mval'} \mid \mval' \in \force(\mval)} \\
\gamma^* &: \FullTrace_{\lmachstep} \mapsto \FullTrace_{\machstep} \\
\gamma^*(A) &= \bigcup\limits_{\mastate\ldots \in A}{\gamma'(\mastate\ldots)} \\
\gamma' &: \Trace_{\lmachstep} \to \wp(\Trace_{\machstep}) \\
\gamma'(\epsilon) &= \setof{\epsilon} \\
\gamma'(\mastate\mastate'\ldots) &=
  \setof{\mstate\mstate'\ldots \mid 
          \mstate \in \gamma(\mastate),
          \mstate'\ldots \in \gamma'(\mastate'\ldots)}
\end{align*}

The $\FullTrace$ claim for the range of $\gamma^*$ takes some
justification, though it should be intuitively true. The
nondeterminism from function calls and continuations does not change
across the semantics, so we only care about variable dereference. All
possible concrete steps from a variable dereference are to values that
are in superposition, by inspection of the reduction relations. A formal inductive argument follows.

\begin{lemma}
If $T \in \FullTrace_{\lmachstep}$ then
% Conclusion 1
 $\forall \mastate\ldots \in T. \gamma'(\mastate\ldots) \subseteq \Trace_{\machstep}$ 
and
% Conclusion 2
for all $0 \le i < |\mastate\ldots|-1$, and all $\mstate\ldots \in \gamma(\mastate\ldots)$
if $\mstate_i \equiv \ev{\svar{\mvar},\menv,\msto,\mkont}$ then
for all $\mstate'$ such that $\mstate_i \machstep \mstate'$,
there exists $\mstate''\ldots \in \gamma(\mastate\ldots)$ where
$\forall 0 \le j \le i. \mstate''_j = \mstate_j$ and $\mstate''_{i+1} = \mstate'$.
\end{lemma}
\begin{proof}
Let $\mastate\ldots \in T$ be arbitrary. By induction on $\mastate\ldots$:
\begin{byCases}
 \case{\text{Base } \epsilon}{
   First conclusion by definition of $\Trace$ and second by vacuity (no such $i$ exists).}
 \case{\text{Induction step } \mastate_0 \lmachstep^* \mastate_n \lmachstep \mastate_{n+1}}{
  By IH, $\gamma'(\mastate_0\ldots\mastate_n) \subseteq \Trace_{\machstep}$ and
  $\forall 0 \le i < n-1.
   \forall \mstate\ldots \in \gamma(\mastate\ldots).
     \mstate_i \equiv \ev{\svar{\mvar},\menv,\msto,\mkont} \implies 
      \forall \mstate'. (\mstate_i \machstep \mstate' \implies
         \exists \mstate''\ldots \in \gamma(\mastate\ldots).
                 (\forall 0 \le j \le i. \mstate''_j = \mstate_j) \wedge (\mstate''_{i+1} = \mstate')$
  Let $\mstate\ldots \in \gamma'(\mastate_0\ldots\mastate_n)$ be arbitrary.
  By cases on $\mastate_n \lmachstep \mastate_{n+1}$. 
  \begin{byCases}
    \case{\ev[^\mcntr]{\svar\mvar,\menv,\msto,\mkont} \lmachstep
      \co{\mkont, \superposition{\msto(\menv(\mvar))},\msto}}{
      By definition of $\gamma$, $\mstate_n = \ev[^\mcntr]{\svar\mvar,\menv,\msto,\mkont}$.
      By definition of $\machstep$, for all $\mval\in\msto(\menv(\mvar))$,
       $\mstate_n \machstep \co{\mkont,\mval,\msto}$ (and nothing else).
      Since $\mstate\ldots$ was arbitrary, $\gamma(\mastate\ldots) \subseteq \Trace_{\machstep}$.

      Let $0 \le i < n$ and $\mstate\ldots \in
      \gamma(\mastate\ldots)$ (note: rebound) be arbitrary.
      If $i < n - 1$, then the IH applies.
      Otherwise, by definition of $\machstep$, for all $\mstate'$, $\mstate_n \machstep \mstate'$ implies
      $\mstate' \equiv \co{\mkont,\msto,\mval}$ for some $\mval \in \msto(\menv(\mvar))$.
      Thus the final witness is $\mstate\ldots\mstate'$ by definition of $\gamma$.}

    \case{\ev{\slit\mlit,\menv,\msto,\mkont} \lmachstep
      \co{\mkont,\mlit,\msto}}{By definitions of $\machstep, \gamma, \force$ and IH.}

    \case{\ev{\slam\mvar\mexp,\menv,\msto,\mkont} \lmachstep
      \co{\mkont,\clos{\mvar,\mexp,\menv},\msto}}{By definitions of $\machstep, \gamma, \force$ and IH.}

    \case{\ev[^\mcntr]{\sapp[^\mlab]{\mexpi0}{\mexpi1},\menv,\msto,\mkont} \lmachstep
      \ev[^{\mcntr'}]{\mexpi{0},\menv,\msto',\kar[_\mlab^\mcntr]{\mexpi{1},\menv,\maddr}}}{
 where $\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]$
      
       By definitions of $\machstep, \gamma$ and IH.}

    \case{\ev[^\mcntr]{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2},\menv,\msto,\mkont} \lmachstep
      \ev[^{\mcntr'}]{\mexpi0,\menv,\msto',\kif[^\mcntr]{\mexpi1,\mexpi2,\menv,\maddr}}}{
 where $\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]$

        By definitions of $\machstep, \gamma$ and IH.}

    \case{\co{\kmt,\mval,\msto} \lmachstep
      \ans{\msto,\mvalx{u}}}{
       where $\mvalx{u} \in {\force(\mval)}$
       
       By definitions of $\machstep,\gamma,\force$ and IH.}

     \case{\co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr},\mval,\msto}  \lmachstep
       \ev[^{\mcntr'}]{\mexp,\menv,\msto',\kfn[^\mcntr_\mlab]{\maddr_f,\maddr}}}{
       where
       $\begin{array}{ll}
         \maddr_f &= \alloc(\mstate)\\
         \msto' &= \msto\sqcup[\maddr_f\mapsto{\force(\mval)}]
       \end{array}$

      ...}

      \case{\co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr},\mval,\msto}  \lmachstep
        \ap[^{\mcntr'}_\mlab]{\mvalx{u},\mval,\mkont,\msto}}{
        where $\mkont \in \msto(\maddr), \mvalx{u} \in \msto(\maddr_f)$

        ...}

      \case{\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\strue,\msto}  \lmachstep
        \ev[^{\mcntr'}]{\mexpi0,\menv,\msto,\mkont}}{
        where $\mkont\in\msto(\maddr)$

        ...}

      \case{\co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\sfalse,\msto}  \lmachstep
        \ev[^{\mcntr'}]{\mexpi1,\menv,\msto,\mkont}}{
        where $\mkont\in\msto(\maddr)$

        ...}

      \case{\ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mval,\msto,\mkont}  \lmachstep
        \ev[^{\mcntr'}\!]{\mexp,\menv',\msto',\mkont}}{
        where
        $\begin{array}{ll}
          \maddr &= \alloc(\mstate) \\
          \menv' &= \menv[\mvar \mapsto \maddr] \\
          \msto' &= \msto\sqcup[\maddr \mapsto {\force(\mval)}]
        \end{array}$

        ...}

      \case{\ap[^\mcntr_\mlab]{\mop,\mval,\msto,\mkont}  \lmachstep
        \co{\mkont,\mval',\msto}}{
        where $\mvalx{u} \in {\force(\mval)}, \mval'\in\interpdelta(\mop,\mvalx{u})$

        ...}
  \end{byCases}
 }
\end{byCases}
\end{proof}

The idea for abstracting a set of traces is to find all the fanouts
and collapse them into superpositions. We do this inductively by
working with truncated traces of length $n+1$, finding all the next
steps that fan out, and constructing the collapsed next state. The
overall abstraction is the union of all these transformed traces at
all lengths (not truncated).

\begin{align*}
\alpha^* &: \wp(\FullTrace_{\machstep}) \mapsto \wp(\FullTrace_{\lmachstep}) \\
\alpha^*(C) &= \bigcup\limits_{n \le \omega}\alpha_n(C) \\
\alpha_0(C) &= C \cap \setof{\epsilon} \\
\alpha_1(C) &= C \cap \State \\
\mathbf{FIXME:} &\\
\alpha_{n+1}(C) &= \setof{\mastate\ldots\mastate'\mastate'' \mid
                         T \subseteq \trunc(C,n+1)
                         \mastate\ldots\mastate' \in \alpha_{n}(\trunc(C,n)) 0
                         \mstate'' \mstate'} \\
\trunc(\mstate\ldots,0) &= \epsilon \\
\trunc(\mstate\mstate'\ldots,n+1) &= \mstate\trunc(\mstate'\ldots,n) \\
\trunc(C,n) &= \setof{\trunc(\mstate\ldots,) \mid \mstate\ldots \in C}
\end{align*}

\begin{mathpar}
\inferrule{\dom(\msto) = \dom(\msto') \\ \forall \maddr. \msto(\addr) \subseteq \msto'(\maddr)}
          {\msto \sqsubseteq \msto'} \\
\inferrule{\msto \sqsubseteq \msto'}
          {\ev[^\mcntr]{\mexp, \menv, \msto, \mkont} \sqsubseteq
           \ev[^\mcntr]{\mexp, \menv, \msto', \mkont}}
 \qquad
\inferrule{\spchoice{\force(\msto, \mval) \subseteq \force(\msto', \mval')}
                    {\force(\mval) \subseteq \force(\mval')}
          \\ \msto \sqsubseteq \msto'}
          {\co{\mkont,\mval,\msto} \sqsubseteq \co{\mkont, \mval', \msto'}} \\
%
\inferrule{\spchoice
           {\force(\msto, \mval) \subseteq \force(\msto', \mval') \\
            \force(\msto, \mvalx{u}) \subseteq \force(\msto', \mvalx{u}')}
           {\force(\mval) \subseteq \force(\mval') \\
            \force(\mvalx{u}) \subseteq \force(\mvalx{u}')}\\
           \msto \sqsubseteq \msto'}
{\ap[_\mlab^\mcntr]{\mval, \mvalx{u}, \msto} \sqsubseteq \ap[_\mlab^\mcntr]{\mval', \mvalx{u}', \msto'}} \\
%
\inferrule{\spchoice
           {\force(\msto, \mval) \subseteq \force(\msto', \mval')}
           {\force(\mval) \subseteq \force(\mval')}
           \\ \msto \sqsubseteq \msto'}
          {\ans{\msto, \mval} \sqsubseteq \ans{\msto', \mval'}}
 \qquad
\inferrule{\forall \hat{\mstate} \in S, \exists \hat{\mstate}' \in S'. \hat{\mstate} \sqsubseteq \hat{\mstate}'}
          {S \sqsubseteq S'}
\end{mathpar}

\begin{theorem}
$\alpha^* \circ \gamma^* = 1_A$
\end{theorem}
\begin{proof}
  Let $A \subseteq \widehat{\State}^*$ be arbitrary. We show that
  $\alpha^*(\gamma^*(A)) = A$. By definition of $\alpha^*$, this is
  equivalent to $\gamma^*(A) = A$.
\end{proof}

\begin{theorem}
$ \gamma^* \circ \alpha^* = 1_C$
\end{theorem}
\begin{proof}
  Let $C \subseteq \State^*$ be arbitrary. We show that
  $\gamma^*(\alpha^*(C)) = C$. By definition of $\alpha^*$, this is
  equivalent to $\gamma^*(C) = C$.
\end{proof}

}


\subsection{Semantic equivalence with abstract compilation}

We show that in the presence of abstract compilation, even though
there are fewer represented states in the reduction relation, that
there is a bisimulation between the two. Particularly, the compiled
semantics is a WEB refinement (defined in pages 57-64 of Manolios'
dissertation) of the non-compiled semantics. We equate states that
``commit'' to non-$\ev{}$ states.

To differentiate the two states spaces, denote the machine
configuration space from the abstractly-compiled machine as
$\CompState$. We additionally denote the reduction relation as $\cmachstep$.

\begin{align*}
\commit(\ev[^\mcntr]{\mexp,\menv,\msto,\mkont}) &= \commitev(\mcntr,\menv,\msto,\mkont,\mexp) \\
\commit(\mstate) &= \mstate \quad \text{otherwise} \\
\commitev(\mcntr,\menv,\msto,\mkont,\svar{\mvar}) &= \co{\mkont, \spchoice{\saddr{\menv(\mvar)}}{\superposition{\msto(\menv(\mvar))}},\msto} \\
\commitev(\mcntr,\menv,\msto,\mkont,\slit\mlit) &= \co{\mkont,\slit\mlit,\msto} \\
\commitev(\mcntr,\menv,\msto,\mkont,\slam{\mvar,\mexp,\menv}) &= \co{\mkont,\clos{\mvar,\mexp,\menv},\msto} \\
\commitev(\mcntr,\menv,\msto,\mkont,\sapp[^\mlab]{\mexpi0}{\mexpi1}) &=
  \commitev(\mcntr,\menv,\msto',\kar[^\mcntr_\mlab]{\mexpi1, \menv, \maddr},\mexpi0) \\
 \text{ where }\maddr &= \allockont^\mcntr\mlab(\msto,\mkont) \\
       \msto' &= \msto\sqcup[\maddr \mapsto \setof{\mkont}]
\commitev(\mcntr,\menv,\msto,\mkont,\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2}) &=
  \commitev(\mcntr,\menv,\msto',\kif[^\mcntr_\mlab]{\mexpi1, \mexpi2, \menv, \maddr},\mexpi0) \\
 \text{ where }\maddr &= \allockont^\mcntr\mlab(\msto,\mkont) \\
       \msto' &= \msto\sqcup[\maddr \mapsto \setof{\mkont}]
\end{align*}

Next, the refinement map from non-compiled to compiled states.
\begin{align*}
r &: \State \to \CompState \\
%% STATES
r(\ev[^\mcntr]{\mexp,\menv,\msto,\mkont}) &= r(\commit(\ev[^\mcntr]{\mexp,\menv,\msto,\mkont})) \\
r(\co{\mkont, \mval,\msto}) &= \co{r(\mkont), r(\mval), r(\msto)} \\
r(\ap[_\mlab^\mcntr]{\mvalx{u},\mval,\msto,\mkont}) &= \ap[_\mlab^\mcntr]{r(\mvalx{u}),r(\mval),r(\msto),r(\mkont)} \\
r(\ans{\msto,\mval}) &= \ans{r(\msto), r(\mval)} \\[2mm]
%% STORE
r(\msto) &= \lambda \maddr. \setof{r(\mval) \mid \mval \in \msto(\maddr)} \\[2mm]
%% CONTINUATIONS
r(\kmt) &= \kmt \\
r(\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr}) &= \kar[^\mcntr_\mlab]{\compile{\mexp},\menv,\maddr} \\
r(\kfn[^\mcntr_\mlab]{\maddr_f,\maddr}) &= \kfn[^\mcntr_\mlab]{\maddr_f,\maddr} \\
r(\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr}) &= \kif[^\mcntr]{\compile{\mexpi0},\compile{\mexpi1},\menv,\maddr} \\[2mm]
%% VALUES
r(\mop) &= \mop \\
r(\mlit) &= \mlit \\
\spchoice
 {r(\saddr{\maddr}) &= \saddr{\maddr}}
 {r(\superposition{\mval{s}}) &= \superposition{\mval{s}}} \\
r(\clos{\mvar,\mexp,\menv}) &= \clos{\mvar,\compile{\mexp},\menv}
\end{align*}
$r$ terminates because the non-structurally descreasing call case is
guaranteed to not happen unless on a structurally smaller
counterpart. This is because $\commit$ never returns an $\ev{}$
state.

Next we relate states across the different machines with an
equivalence relation $B$ on the two state spaces $S = \State \cup \CompState$,
such that $\forall \mstate \in \State. s B r(s)$. Let $B$ be the reflexive, symmetric closure of $B^*$:
\begin{mathpar}
\inferrule{r(s) = s'}{s B^* s'}
\end{mathpar}

Finally, we show that $B$ is a WEB on the transition system
$\langle S, \Rightarrow \rangle$ where $\Rightarrow = \machstep \cup \cmachstep$.

Let $\langle W, \lessdot \rangle$ be the well-ordered set of expressions (ordered structurally) with a bottom element $\bot$.
\begin{align*}
\erankt(\ev[^\mcntr]{\mexp,\menv,\msto,\mkont}) &= \mexp \\
\erankt(\mstate) &= \bot \quad \text{otherwise} \\
\erankl(s,s') &= 0 \quad \text{{\it Unnecessary}}
\end{align*}

We need one lemma:
\begin{lemma}[Compile/Commit]
For all $\mcntr,\mexp,\menv,\msto,\mkont$,
$\compile{\mexp}^\mcntr(\menv,r(\msto),r(\mkont)) = r(\ev[^\mcntr]{\mexp,\menv,\msto,\mkont})$.
\end{lemma}
\begin{proof}
By induction on $\mexp$.
\begin{byCases}
 \case{\text{Base: } \svar{\mvar}}{By definitions of $\compile{\_}, r, \commit$.}
 \case{\text{Base: } \slit{\mlit}}{By definitions of $\compile{\_}, r, \commit$.}
 \case{\text{Induction step: } \slam{\mvar}{\mexp'}}{By definitions of $\compile{\_}, r, \commit$.}
 \case{\text{Induction step: } \sapp[^\mlab]{\mexpi0}{\mexpi1}}{
   By IH, $\compile{\mexpi0}^\mcntr(\menv,r(\msto'),r(\mkont')) =
           r(\ev[^\mcntr]{\mexpi0}{\menv,\msto',\mkont'})$
   where $\mkont' = \kar[^\mcntr_\mlab]{\mexpi1,\menv,\maddr}$
 and $\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]$
  Thus holds by definitions of $r, \commit, \compile{\_}$.}
 \case{\text{Induction step: } \sif{\mexpi0}{\mexpi1}{\mexpi2}}{
   By IH, $\compile{\mexpi0}^\mcntr(\menv,r(\msto'),r(\mkont')) =
           r(\ev[^\mcntr]{\mexpi0}{\menv,\msto',\mkont'})$
   where $\mkont' = \kif[^\mcntr_\mlab]{\mexpi1,\mexpi2,\menv,\maddr}$
 and $\maddr_\mkont = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msto' = \msto\sqcup[\maddr_\mkont \mapsto \setof{\mkont}]$
  Thus holds by definitions of $r, \commit, \compile{\_}$.}
\end{byCases}
\end{proof}

\begin{theorem}
$B$ is a WEB on the transition system $\langle S, \Rightarrow \rangle$.
\end{theorem}
\begin{proof}
Let $s,u,w \in S$ be arbitrary such that $s B w$ and $s \Rightarrow u$.
If $w = s$, the first case of WEB trivially holds with witness $u$. We assume $w \neq s$. Thus $w = r(s)$.
By cases on $s \Rightarrow u$:
\begin{byCases}
%% NON-COMPILED
%% EVAL
\case{
 \ev{\svar\mvar,\menv,\msto,\mkont} \machstep
 \co{\mkont, \spchoice{\saddr{\menv(\mvar)}}{\superposition{\msto(\menv(\mvar))}},\msto}}{

Since $w = r(s)$, $w = r(u)$ by definition of $r$. The second case of
WEB holds by definition of $\erankt$, $\lessdot$ and case analysis on
$w$.}

\case{
 \ev{\slit\mlit,\menv,\msto,\mkont} \machstep
 \co{\mkont,\mlit,\msto}}{

Since $w = r(s)$, $w = r(u)$ by definition of $r$. The second case of
WEB holds by definition of $\erankt$, $\lessdot$ and case analysis on
$w$.}

\case{
 \ev{\slam\mvar\mexp,\menv,\msto,\mkont} \machstep
 \co{\mkont,\clos{\mvar,\mexp,\menv},\msto}}{

Since $w = r(s)$, $w = r(u)$ by definition of $r$. The second case of
WEB holds by definition of $\erankt$, $\lessdot$ and case analysis on
$w$.}

\case{
 \ev[^\mcntr]{\sapp[^\mlab]{\mexpi0}{\mexpi1},\menv,\msto,\mkont} \machstep
 \ev[^\mcntr]{\mexpi{0},\menv,\msto',\kar[_\mlab^\mcntr]{\mexpi{1},\menv,\maddr}}}{
 where $\maddr = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msto' = \msto\sqcup[\maddr \mapsto \setof{\mkont}]$

By definition of $\commit$, $r(u) = w$, thus $u B w$.  By definition
of $\lessdot$, $erankt(u) < erankt(s)$.  Thus the second case of WEB
holds.}

\case{
 \ev[^\mcntr]{\sif[^\mlab]{\mexpi0}{\mexpi1}{\mexpi2},\menv,\msto,\mkont} \machstep
 \ev[^\mcntr]{\mexpi0,\menv,\msto',\kif[^\mcntr]{\mexpi1,\mexpi2,\menv,\maddr}}}{
 where $\maddr = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msto' = \msto\sqcup[\maddr \mapsto \setof{\mkont}]$

By definition of $\commit$, $r(u) = r(s) = w$. By definition of
$\lessdot$, $\erankt(u) \lessdot \erankt(s)$. Thus the second case of
WEB holds.}

%% CONTINUE
\case{
 \co{\kmt,\mval,\msto} \machstep
 \ans{\msto,\mvalx{u}}}{
  where $\mvalx{u} \in \spchoice{\force(\msto, \mval)}{\force(\mval)}$

By definition of $\Rightarrow, \cmachstep$, $w \Rightarrow r(u)$, satisfying the
first case of WEB.}

\case{
 \co{\kar[^\mcntr_\mlab]{\mexp,\menv,\maddr},\mval,\msto} \machstep
 \ev[^\mcntr]{\mexp,\menv,\msto',\kfn[^\mcntr_\mlab]{\maddr_f,\maddr}}}{
  where $\maddr_f = \alloc(\mstate), \msto' = \msto\sqcup[\maddr_f \mapsto \spchoice{\force(\msto,\mval)}{\force(\mval)}$

By definition of $\Rightarrow, \cmachstep$,
$w \Rightarrow \compile{\mexp}^{\mcntr}(\menv,r(\msto'),r(\kfn[^\mcntr_\mlab]{\maddr_f,\maddr}))$.
By the compile/commit lemma, $w \Rightarrow r(u)$.
Thus the first case of WEB holds with witness $r(u)$.}

\case{
 \co{\kfn[^\mcntr_\mlab]{\maddr_f,\maddr},\mval,\msto}  \machstep
 \ap[^\mcntr_\mlab]{\mvalx{u},\mval,\mkont,\msto}}{
  where $\mkont \in \msto(\maddr), \mvalx{u} \in \msto(\maddr_f)$

By definition of $\cmachstep$, $w \cmachstep r(u)$, satisfying the
first case of WEB.}

\case{
 \co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\strue,\msto}  \machstep
 \ev[^\mcntr]{\mexpi0,\menv,\msto,\mkont}}{
  where $\mkont\in\msto(\maddr)$

By definition of $\Rightarrow, \cmachstep$, $w \Rightarrow \compile{\mexpi0}^{\mcntr}(\menv,r(\msto),r(\mkont))$.
By the compile/commit lemma, $w \Rightarrow r(u)$.
Thus the first case of WEB holds with witness $r(u)$.}

\case{
 \co{\kif[^\mcntr]{\mexpi0,\mexpi1,\menv,\maddr},\sfalse,\msto}  \machstep
 \ev[^\mcntr]{\mexpi1,\menv,\msto,\mkont}}{
  where $\mkont\in\msto(\maddr)$

By definition of $\Rightarrow, \cmachstep$, $w \Rightarrow \compile{\mexpi0}^{\mcntr}(\menv,r(\msto),r(\mkont))$.
By the compile/commit lemma, $w \Rightarrow r(u)$.
Thus the first case of WEB holds with witness $r(u)$.}

%% APPLY
\case{
 \ap[^\mcntr_\mlab]{\clos{\mvar,\mexp,\menv},\mval,\msto,\mkont}  \machstep
 \ev[^{\mcntr'}\!]{\mexp,\menv',\msto',\mkont}}{
  where $\maddr = \alloc(\mstate), \menv' = \menv[\mvar \mapsto \maddr], \msto' = \msto\sqcup[\maddr \mapsto \spchoice{\force(\msto, \mval)}{\force(\mval)}]$

By definition of $\Rightarrow, \cmachstep$,
$w \Rightarrow \compile{\mexp}^{\mcntr'}(\menv',r(\msto'),r(\mkont))$.
By the compile/commit lemma, $w \Rightarrow r(u)$.
Thus the first case of WEB holds with witness $r(u)$.}

\case{
 \ap[^\mcntr_\mlab]{\mop,\mval,\msto,\mkont}  \machstep
 \co{\mkont,\mval',\msto}}{
  where $\mvalx{u} \in \spchoice{\force(\msto, \mval)}{\force(\mval)}, \mval'\in\interpdelta(\mop,\mvalx{u})$

By definition of $\cmachstep$, $w \cmachstep r(u)$, satisfying the
first case of WEB.}

%% COMPILED

\case{s \cmachstep u}{Must be the case that $s = w$, thus the first case of WEB holds.}
\end{byCases}
% (a) case is non-compiled to non-ev
% (b) is for s \equiv ev w is r(s)
% (c) is for s compiled, r(w) = s
\end{proof}

\subsection{Soundness of widened abstract compilation}

\begin{align*}
\prep(S,F,\masto) = S \cup \setof{\ttuple{\mastate}{\masto} \mid \mastate \in F}
\end{align*}

\begin{mathpar}
\inferrule{\masto \sqsubseteq \masto'}{(\mastate,\masto) \sqsubseteq (\mastate,\masto')} \qquad
\inferrule{\prep(S,F,\masto) \sqsubseteq \prep(S',F',\masto')}
          {(S,F,\masto) \sqsubseteq (S',F',\masto')}
\end{mathpar}

\begin{align*}
\alpha(\mstate) &= (\setof{(\mastate,\masto)},\setof{\mastate},\masto) \\
 \text{ where } \mastate,\masto &= \nw(\mstate) \\
\gamma((S,F,\masto)) &=
  \setof{\wn(\mastate,\msto) \mid
         \ttuple{\mastate}{\masto'} \in \prep(S,F,\masto),
         \msto \in \gamma(\masto')} \\
% set of all functions that for all \maddr \in \dom(\masto), map \maddr to a subset of \masto(\maddr)
\gamma(\masto) &= \setof{R' \mid R' \subseteq R, R' \text{ functional}, \dom(R') = \dom(\masto)} \\
 \text{ where } R &= \setof{\ttuple{\maddr}{\hat{\mstor}} \mid
                            \maddr \in\dom(\masto),
                            \hat{\mstor} \subseteq \masto(\maddr)} \\
\alpha^*(C) &= \setof{\alpha(\mstate) \mid \mstate \in C} \\
\gamma^*(A) &= \bigcup\limits_{\mastate \in A}{\gamma(\mastate)}
\end{align*}

\begin{lemma}
$\gamma^* \circ \alpha^* \ge 1_C$
\end{lemma}
\begin{proof}
This is immediate if $\masto \in \gamma(\masto)$, which is true, since
$\masto(\maddr) \subseteq \masto(\maddr)$.
\end{proof}

\begin{lemma}
$\alpha^* \circ \gamma^* \le 1_A$
\end{lemma}
\begin{proof}
Let $A \subseteq \System$ be arbitrary.
It suffices to show that $\alpha^*(\gamma^*(A)) \sqsubseteq A$.
Let $(S,F,\masto) \in A$ be arbitary.
Let $(\mastate,\masto) \in S$ be arbitrary.
By definition of $\gamma$, $\masto \in \gamma(\masto)$.
Thus $\wn(\mastate,\masto) \in \gamma^*(A)$.
By definition of $\alpha^*,\alpha$, $(\setof{\ttuple{\mastate}{\masto}},\setof{\mastate},\masto) \in \alpha^*(\gamma^*(A))$.
By definition of $\prep,\sqsubseteq$, $(\setof{\ttuple{\mastate}{\masto}},\setof{\mastate},\masto) \sqsubseteq (S,F,\masto)$.
Thus since $(S,F,\masto)$ was arbitrary, $\alpha^*(\gamma^*(A)) \sqsubseteq A$.
\end{proof}

\begin{theorem}
If $\mstate \cmachstep \mstate'$ and $\alpha(\mstate) \sqsubseteq (S,F,\masto)$
then there exist $S',F',\masto'$ such that
$(S,F,\masto) \machstep (S',F',\masto')$ and
$\alpha(\mstate') \sqsubseteq (S',F',\masto')$
\end{theorem}
\begin{proof}
By definition of $\alpha, \sqsubseteq$, there exists a $\mastate \in F$
such that, with $\mastate^*,\masto^* = \nw(\mstate)$,
$\mastate = \mastate^*$ and $\masto^* \sqsubseteq \masto$.

Thus, by definition of $\machstep, \nw, \wn,\prep,\sqsubseteq$ (call the result $(S',F',\masto')$),
letting $\mastate^*_1,\masto^*_1 = \nw(\mstate')$,
$\masto^*_1 \sqsubseteq \masto'$ and
$\setof{\ttuple{\mastate^*_1}{\masto'}} \sqsubseteq \prep(S',F',\masto')$.
Thus $\alpha(\mstate') \sqsubseteq(S', F', \masto')$.
\end{proof}

\spchoice{ }{
\subsection{Soundness of widen abstract compilation with delayed call}

TODO
}

\subsection{Semantic equivalence with locally log-based store deltas}

Here we show extensional equality of the relations. We will use $\dmachstep$ for the store
delta semantics and $\dcompile{\_}$ for its compilation function.

Let $\equiv \subseteq \Expr$ be the reflexive, transitive, symmetric
closure of $\equiv^*$ with structural lifting where non-$\Expr$
elements are compared with equality, and that lifted to functions
$\Addr \to \wp(\Storeable)$.
\begin{mathpar}
\inferrule{ }{\dcompile{\mexp} \equiv^* \compile{\mexp}}
\end{mathpar}

\begin{lemma}[Compile store independence]\label{lemma:compile-independence}
Let $\compile{\mexp}^\mcntr(\menv,\msto,\mkont) = \wn(\mastate,\msto')$.
$\exists \msdiff. \msto' = \replay(\msdiff,\msto)$.
\end{lemma}
\begin{proof}
By induction on $\mexp$
\begin{byCases}
 \case{\text{Base } \svar{\mvar}}{Witness $\epsilon$}
 \case{\text{Base } \slit{\mlit}}{Witness $\epsilon$}
 \case{\text{Induction step } \slam{\mvar}{\mexp}}{Witness $\epsilon$}
 \case{\text{Induction step } \sapp{\mexpi0}{\mexpi1}}{
  Let $\maddr = \allockont^\mcntr_\mlab(\msto,\mkont)$.
  Let $\msto'' = \msto\sqcup[\maddr \mapsto \setof{\mkont}]$.
  Let $\mkont' = \kar[_\mlab^{\mcntr}]{\compile{\mexpi1},\menv,\maddr}$.
  By IH with $\mexpi0,\mcntr',\msto'',\mkont'$,
   $\exists \msdiff. \msto' = \replay(\msdiff,\msto'')$.
  Thus the witness is $\cons{\ttuple{\maddr}{\setof{\mkont}}}{\msdiff}$
   by definitions of $\compile{\_}$, $\replay$.}
 \case{\text{Induction step } \sif{\mexpi0}{\mexpi1}{\mexpi2}}{
  Let $\maddr = \allockont^\mcntr_\mlab(\msto,\mkont)$.
  Let $\msto'' = \msto\sqcup[\maddr \mapsto \setof{\mkont}]$.
  Let $\mkont' = \kif[^\mcntr]{\compile{\mexpi1},\compile{\mexpi2},\menv,\maddr}$.
  By IH with $\mexpi0,\mcntr',\msto'',\mkont'$,
   $\exists \msdiff. \msto' = \replay(\msdiff,\msto'')$.
  Thus the witness is $\cons{\ttuple{\maddr}{\setof{\mkont}}}{\msdiff}$
   by definitions of $\compile{\_}$, $\replay$.}
\end{byCases}
\end{proof}

We need an additional property on $\allockont$ such that if $\msto
\equiv \msto'$ and $\mkont \equiv \mkont'$, then
$\allockont^\mcntr_\mlab(\msto,\mkont) =
\allockont^\mcntr_\mlab(\msto',\mkont')$, which is a very reasonable
assumption.

\begin{lemma}[$\replay$ and $\append$]\label{lemma:replay-append}
$\replay(\msdiff,\replay(\msdiff',\msto)) =
 \replay(\append(\msdiff,\msdiff'),\msto)$
\end{lemma}
\begin{proof}
By induction on $\msdiff$.
\end{proof}

\begin{lemma}[Compile coherence]\label{lemma:compile-coherence}
For all $\mexp, \mcntr,\menv,\msto,\msdiff,\mkont,\msto^*,\mkont^*,\msdiff^*$,
let $\dcompile{\mexp}^\mcntr(\menv,\msto,\msdiff,\mkont) = \ttuple{\mastate}{\msdiff'}$
and $\compile{\mexp}^\mcntr(\menv,\msto^*,\mkont^*) = \nw(\mastate',\msto^{*'})$.
If $\msto \equiv \msto^*$, $\msdiff \equiv \msdiff^*$, and $\mkont \equiv \mkont^*$ then
$\mastate' \equiv \mastate$
and there exists an $\msdiff''$ such that
   $\replay(\msdiff'',\replay(\msdiff^*,\msto^*)) \equiv \replay(\msdiff',\msto)$.
\end{lemma}
\begin{proof}
By induction on $\mexp$
\begin{byCases}
 \case{\text{Base } \svar{\mvar}}
  {By definitions of $\dcompile{\_},\compile{\_},\replay,\nw$, witness is $\epsilon$.}
 \case{\text{Base } \slit{\mlit}}
  {By definitions of $\dcompile{\_},\compile{\_},\replay,\nw$, witness is $\epsilon$.}
 \case{\text{Induction step } \slam{\mvar}{\mexp}}
  {By definitions of $\dcompile{\_},\compile{\_},\replay,\nw$, witness is $\epsilon$.}
 
 \case{\text{Induction step } \sapp{\mexpi0}{\mexpi1}}{
  Let $\mkont' = \kar[^\mcntr_\mlab]{\dcompile{\mexpi1},\menv,\maddr}$
  By definition of $\dcompile{\_}$,
  Let $\dcompile{\mexpi0}^{\mcntr'}(\menv,\msto,\msdiff'_1, \mkont')
       = \ttuple{\mastate}{\msdiff'}$
 where $\maddr = \allockont^\mcntr\mlab(\msto,\mkont)$
       $\msdiff'_1 = \cons{\ttuple{\maddr}{\setof{\mkont}}}{\msdiff}$
  Let $\mkont^{*'} = \kar[^\mcntr_\mlab]{\compile{\mexpi1},\menv,\maddr}$.
  By definition of $\compile{\_}$,
   $\compile{\mexpi0}^{\mcntr'}(\menv,\msto^*_1,\mkont^{*'}) =
         \wn(\mastate',\msto^{*'})$
    where $\msto^*_1 = \msto^*\sqcup[\maddr \mapsto \setof{\mkont^*}]$.

  By lemma \ref{lemma:compile-independence}, there exists a $\msdiff^*_1$
   such that $\msto^{*'} = \replay(\msdiff^*_1, \msto^*_1)$

 Let $\msdiff^{*'} = \cons{\ttuple{\maddr}{\setof{\mkont^*}}}{\msdiff^*_1}$.
  By definition of $\replay$, $\msto^{*'} = \replay(\msdiff^{*'},\msto^*)$.

  By IH, with $\mexpi0,\mcntr',\menv,\msto,\msdiff'_1,\mkont',\msto^*,\mkont^{*'},\msdiff^{*'}$,
   $\mastate \equiv \mastate'$ and there exists an $\msdiff''_1$ such that
    $\replay(\msdiff'',\replay(\msdiff^{*'},\msto^*)) \equiv \replay(\msdiff',\msto)$.
  Thus the witness is $\append(\msdiff''_1, \cons{\ttuple{\maddr}{\setof{\mkont^*}}}{\epsilon})$
    by lemma \ref{lemma:replay-append} and associativity of $\append$.}

 \case{\text{Induction step } \sif{\mexpi0}{\mexpi1}{\mexpi2}}{Similar to above case.}
\end{byCases}
\end{proof}

\begin{theorem}
%For all $S, F, \msto, S', F', \msto', S^*, F^*, \msto^*$,
If $S \equiv S^*, F \equiv F^*, \msto \equiv \msto^*$, then
$(S,F,\msto) \machstep (S',F',\msto')$ iff
$\exists S^*_1, F^*_1, \msto^*_1.
  S' \equiv S^*_1 \wedge F' \equiv F^*_1 \wedge \msto' \equiv \msto^*_1 \wedge
  (S^*,F^*,\msto^*) \dmachstep (S^*_1,F^*_1,\msto^*_1)$
\end{theorem}
\begin{proof}
By definitions of $\machstep, \dmachstep, \replay,
\appendall$, commutativity and associativity of $\sqcup$, and the previous lemma.
\end{proof}

\subsection{Semantic equivalence of log-based updates to a timestamped store}

Because the store is monotonically increasing, we know that
$\sqsubseteq$ forms a total order on stores in the system. We use this
information to sort and index the stores. Call the timestamped reduction relation $\nmachstep$.

\begin{align*}
\alpha((S,F,\msto)) &= (\alpha(S,\Sigma), F, \Sigma, |\Sigma|-1) \\
\text{ where } \Sigma &= \lambda n. \sorted_n \\
               \sorted &= \sort(\setof{\msto \mid \ttuple{\_}{\msto} \in \prep(S,F,\msto)},\sqsubseteq) \\
\alpha(S,\Sigma) &=
   \setof{\ttuple{\mstate}
                 {\map((\lambda\msto.|\Sigma|-\mathit{indexof}(\Sigma,\msto)-1),\sort(\setof{\msto \mid \ttuple{\mstate}{\msto} \in S}, \sqsupseteq))}
           \mid \ttuple{\mstate,\_} \in S} \\
\gamma((S,F,\Sigma,n)) &= (\gamma(S,\Sigma), F, \hd(\Sigma)) \\
\gamma(S,\Sigma) &= \setof{\ttuple{\mstate}{\Sigma(\ell_i)} \mid S(\mstate) = \ell, 0 \le i < |\ell|}
\end{align*}

%% \begin{lemma}
%% $\gamma \circ \alpha = 1_C$
%% \end{lemma}
%% \begin{proof}
%% TODO
%% \end{proof}

%% \begin{lemma}
%% $\alpha \circ \gamma \circ = 1_C$
%% \end{lemma}
%% \begin{proof}
%% TODO
%% \end{proof}
\newcommand{\fnmerge}{\mathit{merge}}
\newcommand{\last}{\mathit{last}}
\newcommand{\snapshot}{\mathit{snapshot}}
\newcommand{\firstunder}{\mathit{firstunder}}
\newcommand{\size}{\mathit{size}}
\begin{align*}
\msto_{\Xi} \in \Store_{\Xi} &= \Addr to \Valstack \\
\mvalstack \in \Valstack &= (\Timestamp \times \wp(\Storeable))^* \\
\alpha_\msto(\epsilon) &= \alpha_\msto(\lambda\maddr.\varnothing) = \lambda\maddr. \epsilon \\
\alpha_\msto(\msto) &= \lambda\maddr. \ttuple{0}{\msto(\maddr)} \\
\alpha_\msto(\msto\msto'\ldots) &= \fnmerge(\msto,\alpha_\msto(\msto'\ldots)) \\
\fnmerge(\msto,\msto_{\Xi}) &=
  \lambda\maddr.
    \left\{
      \begin{array}{ll}
        \cons{\ttuple{t+1}{\mval{s} \sqcup \msto(\maddr)}}{\msto_{\Xi}(\maddr)} & \text{ if } \mval{s} \neq \msto(\maddr) \\
        \msto_{\Xi}(\maddr) & \text{ otherwise}
      \end{array}
    \right.
\\
\text{ where } t &= \size(\msto_{\Xi}) \\
\mval{s} &= \pi_1(\hd(\msto_{\Xi}(\maddr))) \\              
\size(\bot) &= -1 \\
\size(\msto_{\Xi}) &= \max\setof{t \mid \msto_{\Xi}(\maddr) \equiv \cons{\ttuple{t}{\mval{s}}}{\mvalstack}} \\
\gamma_\msto(\msto_{\Xi}) &= \snapshot(\msto_{\Xi},n)\ldots_n \text{ where } n = \size(\msto_{\Xi}) \text{ down to } 0 \\
\snapshot(\msto_{\Xi},n) &= \lambda \maddr. \firstunder(\msto_{\Xi}(\maddr),n) \\
\firstunder(\epsilon,n) &= \varnothing \\
\firstunder(\cons{\ttuple{t}{\mval{s}}}{\mvalstack},n) &= 
  \left\{\begin{array}{ll}\mval{s} & \text{ if }t \le n \\
                          \firstunder(\mvalstack,n) & \text{ otherwise}
         \end{array}\right.
\end{align*}

Of course we rely on the timestamps being sequential from 0 to $n$ (including each number in the range), so
we add a well-formedness condition on $\Store_{\Xi}$:
\newcommand{\wf}{\mathit{wf}}
\newcommand{\ordered}{\mathit{ordered}}
\begin{align*}
\wf_{\Xi}(\msto_{\Xi}) &= (\forall \maddr. \ordered(\msto_{\Xi}(\maddr))) \wedge \forall 0 \le i \le \size(\msto_{\Xi}). \exists \maddr,j. \pi_0(\msto_{\Xi}(\maddr)_j) = i
\end{align*}
\begin{mathpar}
\inferrule{ }{\ordered(\epsilon)} \qquad \inferrule{\mval{s} \neq \varnothing}{\ordered(\ttuple{t}{\mval{s}})} \\
\inferrule{\ordered(\cons{\ttuple{t}{\mval{s}}}{\mvalstack}) \\
           t' > t \\
           \mval{s}' \sqsupset \mval{s}}
          {\ordered(\cons{\ttuple{t'}{\mval{s}'}}{\cons{\ttuple{t}{\mval{s}}}{\mvalstack}})}
\end{mathpar}

Additionally, the stack of stores we deal with must be in order, different, and greatest to least.
\begin{mathpar}
\inferrule{ }{\wf(\epsilon)} \qquad
\inferrule{ }{\wf(\msto)} \qquad
\inferrule{\wf(\cons{\msto}{\Sigma}) \\ \msto' \sqsupset \msto}
          {\wf(\cons{\msto'}{\cons{\msto}{\Sigma}})}
\end{mathpar}

\begin{lemma}[Snapshot order]\label{lemma:snapshot-order}
If $\wf_{\Xi}(\msto_{\Xi})$ then
for all $1 \le n \le \size(\msto_{\Xi})$,
  $\snapshot(\msto_{\Xi},n) \sqsupset \snapshot(\msto_{\Xi},n-1)$.
\end{lemma}
\begin{proof}
By cases on $n$.
\begin{byCases}
 \case{0}{Vacuously true}
 \case{n + 1}
  {Let $\maddr,j$ be the witnesses of the second well-formedness condition with $i = n$.
   By definition of $\ordered$, either $j = |\msto_{\Xi}(\maddr)|-1$ and thus
    $\pi_1(\msto_{\Xi}(\maddr)_0) \sqsupset \snapshot(\msto_{\Xi},n-1)(\maddr) = \varnothing$,
   or the third rule of $\ordered$ applies and $\sqsupset$ holds outright.
\end{byCases}
\end{proof}

\begin{lemma}
If $\wf_{\Xi}(\msto_{\Xi})$ and $\msto \sqsupseteq \snapshot(\msto_{\Xi},\size(\msto_{\Xi}))$
then $wf_{\Xi}(\fnmerge(\msto,\msto_{\Xi}))$
\end{lemma}

\begin{lemma}[Wellformedness (a)]
$\gamma_\msto : \setof{\msto_{\Xi} \mid \msto_{\Xi} \in \Store_{\Xi}, \wf_{\Xi}(\msto_{\Xi})} \to 
               \setof{\Sigma \mid \Sigma \in \Store^*, \wf(\Sigma)}$
\end{lemma}
\begin{proof}
Let $\msto_{\Xi}$ be arbitrary such that $\wf_{\Xi}(\msto_{\Xi})$.
By lemma \ref{lemma:snapshot-order}, and straightforward induction on $\size(\msto_{\Xi})$.
\end{proof}

\begin{lemma}[Wellformedness (b)]
$\alpha_\msto : \setof{\Sigma \mid \Sigma \in \Store^*, \wf(\Sigma)} \to 
               \setof{\msto_{\Xi} \mid \msto_{\Xi} \in \Store_{\Xi}, \wf_{\Xi}(\msto_{\Xi})}$
\end{lemma}
\begin{proof}
Let $\Sigma$ be arbitrary such that $\wf(\Sigma)$.
By induction on $\Sigma$:
\begin{byCases}
 \case{\text{Base } \epsilon \text{ or } \lambda\maddr.\varnothing}
   {Vacuously true by definitions of $\alpha_\msto$, $\ordered$, $\size$ and $\wf_{\Xi}$.}
 \case{\text{Base } \msto \sqsupset \lambda\maddr.\varnothing}
   {By definitons of $\alpha_\msto$, $\ordered$, $\size$ for first condition.
    Second condition witnesses are $\maddr$ such that
     $\msto(\maddr) \neq \varnothing$ (exists by assumption) and 0.}
 \case{\text{Induction step } \cons{\msto}{\cons{\msto'}{\Sigma'}} \text{ such that } \msto \sqsupset \msto'}
  {By IH, $\wf_{\Xi}(\alpha_\msto(\cons{\msto'}{\Sigma'}))$.
   Let $\maddr$ be arbitrary.
   \begin{byCases}
     \case{\maddr \text{ is such that } \msto(\maddr) \sqsupset \msto'(\maddr)}{
       Let $\msto_{\Xi}' = \alpha_\msto(\cons{\msto'}{\Sigma})$.
       By definitions of $\alpha_\msto$, $\fnmerge$,
       $\alpha_\msto(\Sigma)(\maddr) = \cons{\ttuple{t+1}{\msto(\maddr)}}{\msto_{\Xi}'}$,
       where $t = \size(\msto_{\Xi}')$.
       By definition of $\ordered$ and $\wf_{Xi}$, $\ordered(\alpha_\msto(\Sigma)(\maddr))$.
     For the second condition, $i \le t$ is handled by IH.
     Otherwise, the witnesses are $\maddr$ and 0 (and $\maddr$ must exist by assumption).}
     \otherwise{First condition holds by IH. Second by previous reasoning.}
   \end{byCases}}
\end{byCases}
\end{proof}


\begin{lemma}[Well-formed store of value stacks completely abstracts well-formed stack of stores]
  $\alpha_\msto \circ \gamma_\msto = 1_{\Store_{\Xi}}$ and
  $\gamma_\msto \circ \alpha_\msto = 1_{\Store^*}$ with associated
  well-formedness conditions on the spaces.
\end{lemma}
\begin{proof}
First claim:

Let $\msto_{\Xi}$ be arbitrary such that $\wf_{\Xi}(\msto_{\Xi})$. Let $\maddr$ be arbitrary.
We show that $\alpha_\msto(\gamma_\msto(\msto_{\Xi}))(\maddr) = \msto_{\Xi}(\maddr)$.
TODO

Second claim:

Let $\Sigma$ be arbitrary such that $\wf(\Sigma)$. Let $\maddr$ be arbitrary.
We show that $\gamma_\msto(\alpha_\msto(\Sigma)) = \Sigma$.
TODO
\end{proof}

\begin{align*}
\prop(S,\msto) &= \mathit{totally\text{-}ordered}(\Sigma, \sqsubseteq) \wedge \msto \text{ an upper bound of } \Sigma \\
 \text{ where } \Sigma &= \setof{\msto \mid (\_,\msto) \in S} \\
\prop^*(S,\Sigma,n) &= (\forall \mstate, i. 0 \le i < |S(\mstate)| \implies 0 \le \Sigma(\mstate)_i < |\Sigma|) \wedge \\
                  &(\forall i. 0 \le i < |\Sigma|-1 \implies \Sigma(i) \sqsubseteq \Sigma(i+1)) \wedge \\
                  &n = |\Sigma| - 1
\end{align*}

\begin{lemma}[Monotone store collection]\label{monstore}
If $\prop(S,\msto)$ and $(S,F,\msto) \machstep (S',F',msto')$ then $\prop(S',\msto')$
\end{lemma}
\begin{proof}
Since $\forall \Xi,\msto.\replayall(\Xi,\msto) \sqsupseteq \msto$, this is trivial.
\end{proof}

\begin{lemma}[Monotone store timestamps]\label{montime}
If $\prop^*(S,\Sigma,n)$ and $(S,F,\Sigma,n) \machstep (S',F',\Sigma',n')$ then $\prop^*(S',\Sigma',n')$
\end{lemma}
\begin{proof}
Since $\forall \Xi,\msto. \text{let } \msto',\updatedp = \replaychangeall(\Xi,\msto) \text{ in } \msto' \sqsupseteq \msto$,
this is trivial.
\end{proof}

\begin{lemma}[Change is change]
For all $\msdiff,\msto,\joinp$, let $\replaychange(\msdiff,\msto,\joinp) = \msto',\joinp'$.
$\joinp \vee (\joinp' \iff \msto \neq \msto')$ and $\msto' = \replay(\msdiff,\msto)$.
\end{lemma}
\begin{proof}
By induction on $\msdiff$.
\begin{byCases}
 \case{\text{Base } \bot}{
  By definition of $\replaychange,\replay$, $\msto = \msto' = \replay(\bot, \msto)$ and $\joinp = \joinp'$.}
 \case{\text{Induction step } \msdiff'[\maddr \mapsto \hat{\mstor}]}{
  Let $\replaychange(\msdiff', \msto^*, \joinp \vee \joinp^*) = \msto^*_1,\joinp^*_1$
   where $\hat{\mstor}' = \hat{\mstor} \sqcup \msto(\maddr)$,
         $\msto^* = \msto[\maddr \mapsto \hat{\mstor}']$, $\joinp^* = \hat{\mstor}' \deceq \msto(\maddr)$.
  If $\joinp^*$, then $\msto^*_1 \neq \msto$ and $\joinp^*_1$ because $\replaychange$ monotonically increases $\msto$ and $\joinp$.
  Otherwise, by IH, if $\joinp$, then $\joinp^*_1$; otherwise, $\msto^*_1 \neq \msto^* \iff \joinp^*_1$.
  Also by IH, $\msto^*_1 = \replay(\msdiff',\msto^*)$.
  Thus by definition of $\replay$, $\msto' = \replay(\msdiff,\msto)$.}
\end{byCases}
\end{proof}

\begin{lemma}[Change all is change]
For all $\Xi \text{ finite}, \msto, \updatedp$, let $\replaychangeall(\Xi,\msto,\updatedp) = \msto',\updatedp'$.
$\updatedp \vee (\updatedp' \iff \msto \neq \msto')$ and $\msto' = \replayall(\Xi,\msto)$
\end{lemma}
\begin{proof}
By induction on $\Xi$.
\begin{byCases}
 \case{\text{Base } \varnothing}{
   By definition of $\replaychange$, $\replay$,
   $\msto = \msto' = \replay(\varnothing,\msto)$ and $\updatedp = \updatedp'$.}
 \case{\text{Induction step } \setof{\msdiff}\cup\Xi'}{
  Let $\replaychangeall(\Xi', \msto^*, \updatedp \vee \updatedp^*) = \msto^*_1,\updatedp^*_1$
   where $\replaychange(\msdiff,\msto,\updatedp) = \msto^*,\updatedp^*$.
   By the previous lemma, $\updatedp \vee (\updatedp^* \iff \msto \neq \msto^*)$
   and $\msto^* = \replay(\msdiff,\msto)$..
   If $\updatedp^*$ then $\msto \neq msto^*_1$ and $\updatedp^*_1$ because $\replaychangeall$ monotonically increases $\msto$ and $\updatedp$.
   Otherwise, by IH, if $\updatedp$, then $\updatedp^*_1$; otherwise $\msto^*_1 \neq \msto^* \iff \updatedp^*_1$.
   Also by IH, $\msto^*_1 = \replayall(\Xi',\msto^*)$.
   Thus, by definition of $\replayall$, $\msto' = \replayall(\Xi,\msto)$.}
\end{byCases}
\end{proof}

\begin{theorem}
If $(S,F,\msto) \machstep (S',F',\msto')$ and $\prop(S,\msto)$ and $\alpha((S,F,\msto))
\sqsubseteq (S^*,F,\Sigma,n)$ then there exist $S^*_1,\Sigma',n'$ such
that $(S^*,F,\Sigma,n) \nmachstep (S^*_1,F',\Sigma',n')$ and
$\alpha((S',F',\msto')) \sqsubseteq (S^*_1,F',\Sigma',n')$.
\end{theorem}
\begin{proof}
By definition of $\alpha$, and lemma \ref{monstore}, $\Sigma(n) = \msto$.
By definitions of $\nmachstep$, $\machstep$, $\alpha$ and the previous lemma, $\msto' = \Sigma'(n')$.
By definitions of $\nmachstep$, $\machstep$, $\alpha$, and the previous statement, $\alpha(S') = S^*_1$.
By definition of $\alpha$ and lemma \ref{monstore}, $(S^*,F,\Sigma,n) \nmachstep (S^*_1,F',\Sigma',n')$ and $\alpha((S',F',\msto')) \sqsubseteq (S^*_1,F',\Sigma',n')$.
\end{proof}

\begin{theorem}
If $(S,F,\Sigma,n) \nmachstep (S',F',\Sigma',n')$ and
$\gamma((S,F,\Sigma,n)) \sqsubseteq (S^*,F,\msto)$ then there exist
$S^*_1,\msto'$ such that $(S^*,F,\msto) \machstep (S^*_1,F',\msto')$
and $\gamma((S',F',\Sigma',n')) \sqsubseteq (S^*_1,F',\msto')$.
\end{theorem}
\begin{proof}
By definition of $\gamma$, and lemma \ref{montime}, $\Sigma(n) = \msto$.
By definitions of $\nmachstep$, $\machstep$, $\gamma$ and the previous lemma, $\msto' = \Sigma'(n')$.
By definitions of $\nmachstep$, $\machstep$, $\gamma$, and the previous statement, $\gamma(S',\Sigma') = S^*_1$.
By definition of $\gamma$ and lemma \ref{montime}, $(S^*,F,\msto) \machstep (S^*_1,F',\msto')$ and $\gamma((S',F',\Sigma',n')) \sqsubseteq (S^*_1,F',\msto')$.
\end{proof}

\end{document}
